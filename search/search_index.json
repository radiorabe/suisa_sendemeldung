{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"suisa_sendemeldung","text":"<p>ACRCloud client that fetches data on our playout history and formats them in a CSV file format containing the data (like Track, Title and ISRC) requested by SUISA. Also takes care of sending the report to SUISA via email for hands-off operations.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can build a Docker image using the included Dockerfile:</p> <pre><code>git clone https://github.com/radiorabe/suisa_sendemeldung\ncd suisa_sendemeldung\npodman build -t suisa_sendemeldung .\n</code></pre> <p>Then you can run it by passing in command line switches:</p> <pre><code>podman run --rm suisa_sendemeldung --bearer-token abcdefghijklmnopqrstuvwxyzabcdef --stream_id a-bcdefgh --stdout\n</code></pre> <p>Or by setting environment variables:</p> <pre><code>podman run --rm --env BEARER_TOKEN=abcdefghijklmnopqrstuvwxyzabcdef --env STREAM_ID=a-bcdefgh --env STDOUT=True suisa_sendemeldung\n</code></pre> <p>A prebuilt image is available from the GitHub Package Registry:</p> <pre><code>docker pull ghcr.io/radiorabe/suisasendemeldung:master\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>This is the output of <code>suisa_sendemeldung -h</code>. <pre><code>usage: suisa_sendemeldung [-h] --bearer-token BEARER_TOKEN --project-id\n                          PROJECT_ID --stream-id STREAM_ID\n                          [--station-name STATION_NAME]\n                          [--station-name-short STATION_NAME_SHORT] [--file]\n                          [--filetype {xlsx,csv}] [--email]\n                          [--email-from EMAIL_FROM] [--email-to EMAIL_TO]\n                          [--email-cc EMAIL_CC] [--email-bcc EMAIL_BCC]\n                          [--email-server EMAIL_SERVER]\n                          [--email-login EMAIL_LOGIN]\n                          [--email-pass EMAIL_PASS]\n                          [--email-subject EMAIL_SUBJECT]\n                          [--email-text EMAIL_TEXT]\n                          [--email-footer EMAIL_FOOTER]\n                          [--responsible-email RESPONSIBLE_EMAIL]\n                          [--start-date START_DATE] [--end-date END_DATE]\n                          [--last-month] --timezone TIMEZONE [--locale LOCALE]\n                          [--filename FILENAME] [--stdout]\n\nACRCloud client for SUISA reporting @ RaBe.\n\noptions:\n  -h, --help            show this help message and exit\n  --bearer-token BEARER_TOKEN\n                        the bearer token for ACRCloud (required) [env var:\n                        BEARER_TOKEN]\n  --project-id PROJECT_ID\n                        the id of the project at ACRCloud (required) [env var:\n                        PROJECT_ID]\n  --stream-id STREAM_ID\n                        the id of the stream at ACRCloud (required) [env var:\n                        STREAM_ID]\n  --station-name STATION_NAME\n                        Station name, used in Output and Emails [env var:\n                        STATION_NAME]\n  --station-name-short STATION_NAME_SHORT\n                        Shortname for station as used in Filenames (locally\n                        and in attachment) [env var: STATION_NAME_SHORT]\n  --file                create file [env var: FILE]\n  --filetype {xlsx,csv}\n                        filetype to attach to email or write to file [env var:\n                        FILETYPE]\n  --email               send an email [env var: EMAIL]\n  --email-from EMAIL_FROM\n                        the sender of the email [env var: EMAIL_FROM]\n  --email-to EMAIL_TO   the recipients of the email [env var: EMAIL_TO]\n  --email-cc EMAIL_CC   the cc recipients of the email [env var: EMAIL_CC]\n  --email-bcc EMAIL_BCC\n                        the bcc recipients of the email [env var: EMAIL_BCC]\n  --email-server EMAIL_SERVER\n                        the smtp server to send the mail with [env var:\n                        EMAIL_SERVER]\n  --email-login EMAIL_LOGIN\n                        the username to logon to the smtp server (default:\n                        email_from) [env var: EMAIL_LOGIN]\n  --email-pass EMAIL_PASS\n                        the password for the smtp server [env var: EMAIL_PASS]\n  --email-subject EMAIL_SUBJECT\n                        The subject of the email, placeholders are\n                        $station_name, $year and $month [env var:\n                        EMAIL_SUBJECT]\n  --email-text EMAIL_TEXT\n                        A template for the Email text, placeholders are\n                        $station_name, $month, $year, $previous_year,\n                        $responsible_email, and $email_footer. [env var:\n                        EMAIL_TEXT]\n  --email-footer EMAIL_FOOTER\n                        Footer for the Email [env var: EMAIL_FOOTER]\n  --responsible-email RESPONSIBLE_EMAIL\n                        Used to hint whom to contact in the emails text. [env\n                        var: RESPONSIBLE_EMAIL]\n  --start-date START_DATE\n                        the start date of the interval in format YYYY-MM-DD\n                        (default: 30 days before end_date) [env var:\n                        START_DATE]\n  --end-date END_DATE   the end date of the interval in format YYYY-MM-DD\n                        (default: today) [env var: END_DATE]\n  --last-month          download data of whole last month [env var:\n                        LAST_MONTH]\n  --timezone TIMEZONE   set the timezone for localization [env var: TIMEZONE]\n  --locale LOCALE       set locale for date and time formatting [env var:\n                        LOCALE]\n  --filename FILENAME   file to write to (default:\n                        &lt;station_name_short&gt;_&lt;year&gt;_&lt;month&gt;.csv when reporting\n                        last month, &lt;station_name_short&gt;_&lt;start_date&gt;.csv\n                        else) [env var: FILENAME]\n  --stdout              also print to stdout [env var: STDOUT]\n\nArgs that start with '--' (eg. --bearer-token) can also be set in a config\nfile (/etc/suisa_sendemeldung.conf or /home/hairmare/suisa_sendemeldung.conf\nor suisa_sendemeldung.conf). Config file syntax allows: key=value, flag=true,\nstuff=[a,b,c] (for details, see syntax at https://goo.gl/R74nmi). If an arg is\nspecified in more than one place, then commandline values override environment\nvariables which override config file values which override defaults.\n</code></pre></p>"},{"location":"#configuration","title":"Configuration","text":"<p>You can configure this script either with a configuration file (default is <code>suisa_sendemeldung.conf</code>), environment variables or command line arguments as shown above.</p> <p>Command line arguments override environment variables which themselves override settings in the configuration file.</p>"},{"location":"#configuration-file","title":"Configuration file","text":"<p>The configuration files will be evaluated in the following order (last takes precedence over first):</p> <ol> <li><code>/etc/suisa_sendemeldung.conf</code></li> <li><code>$HOME/suisa_sendemeldung.conf</code></li> <li><code>./suisa_sendemeldung.conf</code></li> </ol> <p>For details on how to set configuration values, have a look at suisa_sendemeldung.conf.</p>"},{"location":"#environment-variables","title":"Environment variables","text":"<p>Environment variables can also be passed as options. The relevant variables are listed in the Usage part of this document. For example run the script as follows:</p> <pre><code>BEARER_TOKEN=abcdefghijklmnopqrstuvwxyzabcdef STREAM_ID=a-bcdefgh STDOUT=True ./suisa_sendemeldung.py\n</code></pre>"},{"location":"#command-line-switches","title":"Command line switches","text":"<p>As documented in Usage, you can also pass in options on the command line as arguments. Simply run the script as follows:</p> <pre><code>./suisa_sendemeldung.py --bearer-token=abcdefghijklmnopqrstuvwxyzabcdef --stream_id=a-bcdefgh --stdout\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>Snapshot testing is used to test the help output, you can update the snapshots like so: <pre><code>poetry run pytest -- --snapshot-update\n</code></pre></p>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. There is a GitHub Action in .github/workflows/semantic-release.yaml that uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p> <p>Once a commit has landed on the <code>main</code> branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses twine to publish the package to pypi. The <code>release.yaml</code> action also takes care of pushing a container image to GitHub Packages.</p>"},{"location":"reference/acrclient/","title":"Acrclient","text":"<p>module containing the ACRCloud client.</p>"},{"location":"reference/acrclient/#acrclient.ACRClient","title":"<code>ACRClient</code>","text":"<p>             Bases: <code>Client</code></p> <p>ACRCloud client wrapper to fetch metadata.</p> <pre><code>bearer_token: The bearer token for ACRCloud.\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>class ACRClient(Client):\n    \"\"\"ACRCloud client wrapper to fetch metadata.\n\n    Arguments:\n    ---------\n        bearer_token: The bearer token for ACRCloud.\n\n    \"\"\"\n\n    # format of timestamp in api answer\n    TS_FMT = \"%Y-%m-%d %H:%M:%S\"\n    # timezone of ACRCloud\n    ACR_TIMEZONE = \"UTC\"\n\n    def __init__(\n        self: Self, bearer_token: str, base_url: str = \"https://eu-api-v2.acrcloud.com\"\n    ) -&gt; None:\n        \"\"\"Init subclass with default_date.\"\"\"\n        super().__init__(bearer_token=bearer_token, base_url=base_url)\n        self.default_date: date = date.today() - timedelta(days=1)  # noqa: DTZ011\n\n    def get_data(\n        self: Self,\n        project_id: int,\n        stream_id: str,\n        requested_date: date | None = None,\n        timezone: str = ACR_TIMEZONE,\n    ) -&gt; Any:  # noqa: ANN401\n        \"\"\"Fetch metadata from ACRCloud for `stream_id`.\n\n        Arguments:\n        ---------\n            project_id: The Project ID of the stream.\n            stream_id: The ID of the stream.\n            requested_date: The date of the entries you want (default: yesterday).\n            timezone: The timezone to use for localization.\n\n        Returns:\n        -------\n            json: The ACR data from date\n\n        \"\"\"\n        if requested_date is None:\n            requested_date = self.default_date\n        data = self.get_bm_cs_projects_results(\n            project_id=project_id,\n            stream_id=stream_id,\n            params=GetBmCsProjectsResultsParams(\n                type=\"day\",\n                date=requested_date.strftime(\"%Y%m%d\"),\n            ),\n        )\n        for entry in data:\n            metadata = entry.get(\"metadata\")\n            ts_utc = pytz.utc.localize(\n                datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n            )\n            ts_local = ts_utc.astimezone(pytz.timezone(timezone))\n            metadata.update({\"timestamp_local\": ts_local.strftime(ACRClient.TS_FMT)})\n\n        return data\n\n    def get_interval_data(  # noqa: PLR0913, ANN201\n        self: Self,\n        project_id: int,\n        stream_id: str,\n        start: date,\n        end: date,\n        timezone: str = ACR_TIMEZONE,\n    ):  # pylint: disable-msg=too-many-locals,too-many-arguments\n        \"\"\"Get data specified by interval from start to end.\n\n        Arguments:\n        ---------\n            project_id: The ID of the project.\n            stream_id: The ID of the stream.\n            start: The start date of the interval.\n            end: The end date of the interval.\n            timezone (optional): will be passed to `get_data()`.\n\n        Returns:\n        -------\n            json: The ACR data from start to end.\n\n        \"\"\"\n        trim = False\n        # if we have to localize the timestamps we may need more data\n        if timezone != ACRClient.ACR_TIMEZONE:\n            # compute utc offset\n            offset = pytz.timezone(timezone).utcoffset(datetime.now())  # noqa: DTZ005\n            # decrease start by 1 day if we're ahead of utc\n            if offset &gt; timedelta(seconds=1):\n                computed_start = start - timedelta(days=1)\n                computed_end = end\n                trim = True\n            # increase end by 1 day if we're behind of utc\n            elif offset &lt; timedelta(seconds=1):\n                computed_start = start\n                computed_end = end + timedelta(days=1)\n                trim = True\n        else:\n            computed_start = start\n            computed_end = end\n\n        dates = []\n        ptr = computed_start\n        while ptr &lt;= computed_end:\n            dates.append(ptr)\n            ptr += timedelta(days=1)\n        data = []\n        # make the prefix longer by this amount so tqdm lines up with\n        # the one in the main code\n        ljust_amount: int = 27\n        for ptr in tqdm(dates, desc=\"load ACRCloud data\".ljust(ljust_amount)):\n            data += self.get_data(\n                project_id,\n                stream_id,\n                requested_date=ptr,\n                timezone=timezone,\n            )\n\n        # if timestamps are localized we will have to removed the unneeded entries.\n        if trim:\n            for entry in reversed(data):\n                metadata = entry.get(\"metadata\")\n                timestamp = metadata.get(\"timestamp_local\")\n                timestamp_date = datetime.strptime(timestamp, ACRClient.TS_FMT).date()  # noqa: DTZ007\n                if timestamp_date &lt; start or timestamp_date &gt; end:\n                    data.remove(entry)\n\n        return data\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.__init__","title":"<code>__init__(bearer_token, base_url='https://eu-api-v2.acrcloud.com')</code>","text":"<p>Init subclass with default_date.</p> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def __init__(\n    self: Self, bearer_token: str, base_url: str = \"https://eu-api-v2.acrcloud.com\"\n) -&gt; None:\n    \"\"\"Init subclass with default_date.\"\"\"\n    super().__init__(bearer_token=bearer_token, base_url=base_url)\n    self.default_date: date = date.today() - timedelta(days=1)  # noqa: DTZ011\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.get_data","title":"<code>get_data(project_id, stream_id, requested_date=None, timezone=ACR_TIMEZONE)</code>","text":"<p>Fetch metadata from ACRCloud for <code>stream_id</code>.</p> <pre><code>project_id: The Project ID of the stream.\nstream_id: The ID of the stream.\nrequested_date: The date of the entries you want (default: yesterday).\ntimezone: The timezone to use for localization.\n</code></pre> <pre><code>json: The ACR data from date\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def get_data(\n    self: Self,\n    project_id: int,\n    stream_id: str,\n    requested_date: date | None = None,\n    timezone: str = ACR_TIMEZONE,\n) -&gt; Any:  # noqa: ANN401\n    \"\"\"Fetch metadata from ACRCloud for `stream_id`.\n\n    Arguments:\n    ---------\n        project_id: The Project ID of the stream.\n        stream_id: The ID of the stream.\n        requested_date: The date of the entries you want (default: yesterday).\n        timezone: The timezone to use for localization.\n\n    Returns:\n    -------\n        json: The ACR data from date\n\n    \"\"\"\n    if requested_date is None:\n        requested_date = self.default_date\n    data = self.get_bm_cs_projects_results(\n        project_id=project_id,\n        stream_id=stream_id,\n        params=GetBmCsProjectsResultsParams(\n            type=\"day\",\n            date=requested_date.strftime(\"%Y%m%d\"),\n        ),\n    )\n    for entry in data:\n        metadata = entry.get(\"metadata\")\n        ts_utc = pytz.utc.localize(\n            datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n        )\n        ts_local = ts_utc.astimezone(pytz.timezone(timezone))\n        metadata.update({\"timestamp_local\": ts_local.strftime(ACRClient.TS_FMT)})\n\n    return data\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.get_interval_data","title":"<code>get_interval_data(project_id, stream_id, start, end, timezone=ACR_TIMEZONE)</code>","text":"<p>Get data specified by interval from start to end.</p> <pre><code>project_id: The ID of the project.\nstream_id: The ID of the stream.\nstart: The start date of the interval.\nend: The end date of the interval.\ntimezone (optional): will be passed to `get_data()`.\n</code></pre> <pre><code>json: The ACR data from start to end.\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def get_interval_data(  # noqa: PLR0913, ANN201\n    self: Self,\n    project_id: int,\n    stream_id: str,\n    start: date,\n    end: date,\n    timezone: str = ACR_TIMEZONE,\n):  # pylint: disable-msg=too-many-locals,too-many-arguments\n    \"\"\"Get data specified by interval from start to end.\n\n    Arguments:\n    ---------\n        project_id: The ID of the project.\n        stream_id: The ID of the stream.\n        start: The start date of the interval.\n        end: The end date of the interval.\n        timezone (optional): will be passed to `get_data()`.\n\n    Returns:\n    -------\n        json: The ACR data from start to end.\n\n    \"\"\"\n    trim = False\n    # if we have to localize the timestamps we may need more data\n    if timezone != ACRClient.ACR_TIMEZONE:\n        # compute utc offset\n        offset = pytz.timezone(timezone).utcoffset(datetime.now())  # noqa: DTZ005\n        # decrease start by 1 day if we're ahead of utc\n        if offset &gt; timedelta(seconds=1):\n            computed_start = start - timedelta(days=1)\n            computed_end = end\n            trim = True\n        # increase end by 1 day if we're behind of utc\n        elif offset &lt; timedelta(seconds=1):\n            computed_start = start\n            computed_end = end + timedelta(days=1)\n            trim = True\n    else:\n        computed_start = start\n        computed_end = end\n\n    dates = []\n    ptr = computed_start\n    while ptr &lt;= computed_end:\n        dates.append(ptr)\n        ptr += timedelta(days=1)\n    data = []\n    # make the prefix longer by this amount so tqdm lines up with\n    # the one in the main code\n    ljust_amount: int = 27\n    for ptr in tqdm(dates, desc=\"load ACRCloud data\".ljust(ljust_amount)):\n        data += self.get_data(\n            project_id,\n            stream_id,\n            requested_date=ptr,\n            timezone=timezone,\n        )\n\n    # if timestamps are localized we will have to removed the unneeded entries.\n    if trim:\n        for entry in reversed(data):\n            metadata = entry.get(\"metadata\")\n            timestamp = metadata.get(\"timestamp_local\")\n            timestamp_date = datetime.strptime(timestamp, ACRClient.TS_FMT).date()  # noqa: DTZ007\n            if timestamp_date &lt; start or timestamp_date &gt; end:\n                data.remove(entry)\n\n    return data\n</code></pre>"},{"location":"reference/suisa_sendemeldung/","title":"Suisa sendemeldung","text":"<p>SUISA Sendemeldung bugs SUISA with email once per month.</p> <p>Fetches data on our playout history and formats them in a CSV file format containing the data (like Track, Title and ISRC) requested by SUISA. Also takes care of sending the report to SUISA via email for hands-off operations.</p>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.check_duplicate","title":"<code>check_duplicate(entry_a, entry_b)</code>","text":"<p>Check if two entries are duplicates by checking their acrid in all music items.</p> <pre><code>entry_a: first entry\nentry_b: second entry\n</code></pre> <pre><code>True if the entries are duplicates, False otherwise\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def check_duplicate(entry_a: Any, entry_b: Any) -&gt; bool:  # noqa: ANN401\n    \"\"\"Check if two entries are duplicates by checking their acrid in all music items.\n\n    Arguments:\n    ---------\n        entry_a: first entry\n        entry_b: second entry\n\n    Returns:\n    -------\n        True if the entries are duplicates, False otherwise\n\n    \"\"\"\n    try:\n        entry_a = entry_a[\"metadata\"][\"music\"]\n    except KeyError:\n        entry_a = entry_a[\"metadata\"][\"custom_files\"]\n    try:\n        entry_b = entry_b[\"metadata\"][\"music\"]\n    except KeyError:\n        entry_b = entry_b[\"metadata\"][\"custom_files\"]\n    for music_a in entry_a:\n        for music_b in entry_b:\n            if music_a[\"acrid\"] == music_b[\"acrid\"]:\n                return True\n    return False\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.create_message","title":"<code>create_message(sender, recipient, subject, text, filename, filetype, data, cc=None, bcc=None)</code>","text":"<p>Create email message.</p> <pre><code>sender: The sender of the email. Login will be made with this user.\nrecipient: The recipient of the email. Can be a list.\nsubject: The subject of the email.\ntext: The body of the email.\nfilename: The filename of the attachment\nfiletype: The filetype of the attachment\ndata: The attachment data.\ncc: cc recipient\nbcc: bcc recipient\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def create_message(  # noqa: PLR0913\n    sender: str,\n    recipient: str,\n    subject: str,\n    text: str,\n    filename: str,\n    filetype: str,\n    data: Any,  # noqa: ANN401\n    cc: str | None = None,\n    bcc: str | None = None,\n) -&gt; MIMEMultipart:\n    \"\"\"Create email message.\n\n    Arguments:\n    ---------\n        sender: The sender of the email. Login will be made with this user.\n        recipient: The recipient of the email. Can be a list.\n        subject: The subject of the email.\n        text: The body of the email.\n        filename: The filename of the attachment\n        filetype: The filetype of the attachment\n        data: The attachment data.\n        cc: cc recipient\n        bcc: bcc recipient\n\n    \"\"\"\n    msg = MIMEMultipart()\n    msg[\"From\"] = sender\n    msg[\"To\"] = recipient\n    if cc:\n        msg[\"Cc\"] = cc\n    if bcc:\n        msg[\"Bcc\"] = bcc\n    msg[\"Date\"] = formatdate(localtime=True)\n    msg[\"Subject\"] = subject\n    # set body\n    msg.attach(MIMEText(text))\n    msg.attach(get_email_attachment(filename, filetype, data))\n\n    return msg\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.funge_release_date","title":"<code>funge_release_date(release_date='')</code>","text":"<p>Make a release_date from ACR conform to what seems to be the spec.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def funge_release_date(release_date: str = \"\") -&gt; str:\n    \"\"\"Make a release_date from ACR conform to what seems to be the spec.\"\"\"\n    if len(release_date) == 10:  # noqa: PLR2004\n        # we can make it look like what suisa has in their examples if it's the\n        # right length\n        try:\n            return datetime.strptime(release_date, \"%Y-%m-%d\").strftime(\"%Y%m%d\")  # noqa: DTZ007\n        except ValueError:\n            return \"\"\n    # we discard other records since there is no way to convert records like a plain\n    # year into dd/mm/yyyy properly without further guidance from whomever ingests\n    # the data, in some cases this means we discard data that only contain a year\n    # since they dont have that amount of precision.\n    return \"\"\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_arguments","title":"<code>get_arguments(parser, sysargs)</code>","text":"<p>Create :class:<code>ArgumentParser</code> with arguments.</p> <pre><code>parser: the parser to add arguments\nsysargs: sys.arg[1:] or something else for testing\n</code></pre> <pre><code>args: the parsed args from the parser\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_arguments(parser: ArgumentParser, sysargs: list[str]) -&gt; ArgparseNamespace:\n    \"\"\"Create :class:`ArgumentParser` with arguments.\n\n    Arguments:\n    ---------\n        parser: the parser to add arguments\n        sysargs: sys.arg[1:] or something else for testing\n\n    Returns:\n    -------\n        args: the parsed args from the parser\n\n    \"\"\"\n    parser.add_argument(\n        \"--bearer-token\",\n        env_var=\"BEARER_TOKEN\",\n        help=\"the bearer token for ACRCloud (required)\",\n        required=True,\n    )\n    parser.add_argument(\n        \"--project-id\",\n        env_var=\"PROJECT_ID\",\n        help=\"the id of the project at ACRCloud (required)\",\n        required=True,\n    )\n    parser.add_argument(\n        \"--stream-id\",\n        env_var=\"STREAM_ID\",\n        help=\"the id of the stream at ACRCloud (required)\",\n        required=True,\n    )\n    parser.add_argument(\n        \"--station-name\",\n        env_var=\"STATION_NAME\",\n        help=\"Station name, used in Output and Emails\",\n        default=\"Radio Bern RaBe\",\n    )\n    parser.add_argument(\n        \"--station-name-short\",\n        env_var=\"STATION_NAME_SHORT\",\n        help=\"Shortname for station as used in Filenames (locally and in attachment)\",\n        default=\"rabe\",\n    )\n    parser.add_argument(\n        \"--file\",\n        env_var=\"FILE\",\n        help=\"create file\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"--filetype\",\n        env_var=\"FILETYPE\",\n        help=\"filetype to attach to email or write to file\",\n        choices=(\"xlsx\", \"csv\"),\n        default=\"xlsx\",\n    )\n    parser.add_argument(\n        \"--email\",\n        env_var=\"EMAIL\",\n        help=\"send an email\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"--email-from\",\n        env_var=\"EMAIL_FROM\",\n        help=\"the sender of the email\",\n    )\n    parser.add_argument(\n        \"--email-to\",\n        env_var=\"EMAIL_TO\",\n        help=\"the recipients of the email\",\n    )\n    parser.add_argument(\n        \"--email-cc\",\n        env_var=\"EMAIL_CC\",\n        help=\"the cc recipients of the email\",\n    )\n    parser.add_argument(\n        \"--email-bcc\",\n        env_var=\"EMAIL_BCC\",\n        help=\"the bcc recipients of the email\",\n    )\n    parser.add_argument(\n        \"--email-server\",\n        env_var=\"EMAIL_SERVER\",\n        help=\"the smtp server to send the mail with\",\n    )\n    parser.add_argument(\n        \"--email-login\",\n        env_var=\"EMAIL_LOGIN\",\n        help=\"the username to logon to the smtp server (default: email_from)\",\n    )\n    parser.add_argument(\n        \"--email-pass\",\n        env_var=\"EMAIL_PASS\",\n        help=\"the password for the smtp server\",\n    )\n    parser.add_argument(\n        \"--email-subject\",\n        env_var=\"EMAIL_SUBJECT\",\n        help=\"\"\"\n        Template for subject of the email.\n\n        Placeholders are $station_name, $year and $month.\n        \"\"\",\n        default=\"SUISA Sendemeldung von $station_name f\u00fcr $year-$month\",\n    )\n    parser.add_argument(\n        \"--email-text\",\n        env_var=\"EMAIL_TEXT\",\n        help=\"\"\"\n        Template for email text.\n\n        Placeholders are $station_name, $month, $year, $previous_year,\n        $responsible_email, and $email_footer.\n        \"\"\",\n        default=_EMAIL_TEMPLATE,\n    )\n    parser.add_argument(\n        \"--email-footer\",\n        env_var=\"EMAIL_FOOTER\",\n        help=\"Footer for the Email\",\n        default=\"Email generated by &lt;https://github.com/radiorabe/suisa_sendemeldung&gt;\",\n    )\n    parser.add_argument(\n        \"--responsible-email\",\n        env_var=\"RESPONSIBLE_EMAIL\",\n        help=\"Used to hint whom to contact in the emails text.\",\n    )\n    parser.add_argument(\n        \"--start-date\",\n        env_var=\"START_DATE\",\n        help=\"the start date of the interval in format YYYY-MM-DD (default: 30 days\\\n                              before end_date)\",\n    )\n    parser.add_argument(\n        \"--end-date\",\n        env_var=\"END_DATE\",\n        help=\"the end date of the interval in format YYYY-MM-DD (default: today)\",\n    )\n    parser.add_argument(\n        \"--last-month\",\n        env_var=\"LAST_MONTH\",\n        action=\"store_true\",\n        help=\"download data of whole last month\",\n    )\n    parser.add_argument(\n        \"--timezone\",\n        env_var=\"TIMEZONE\",\n        help=\"set the timezone for localization\",\n        required=True,\n        default=\"UTC\",\n    )\n    parser.add_argument(\n        \"--locale\",\n        env_var=\"LOCALE\",\n        help=\"set locale for date and time formatting\",\n        default=\"de_CH\",\n    )\n    parser.add_argument(\n        \"--filename\",\n        env_var=\"FILENAME\",\n        help=\"\"\"\n        Output filename.\n\n        Default:\n        - &lt;station_name_short&gt;_&lt;year&gt;_&lt;month&gt;.csv when reporting last month\n        - &lt;station_name_short&gt;_&lt;start_date&gt;.csv else\n        \"\"\",\n    )\n    parser.add_argument(\n        \"--stdout\",\n        env_var=\"STDOUT\",\n        help=\"also print to stdout\",\n        action=\"store_true\",\n    )\n    args = parser.parse_args(sysargs)\n    validate_arguments(parser, args)  # pragma: no cover\n    return args  # pragma: no cover\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_artist","title":"<code>get_artist(music)</code>","text":"<p>Get artist from a given dict.</p> <pre><code>music: music dict from API\n</code></pre> <pre><code>artist: string representing the artist\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_artist(music: Any) -&gt; str:  # noqa: ANN401\n    \"\"\"Get artist from a given dict.\n\n    Arguments:\n    ---------\n        music: music dict from API\n\n    Returns:\n    -------\n        artist: string representing the artist\n\n    \"\"\"\n    artist = \"\"\n    if music.get(\"artists\") is not None:\n        artists = music.get(\"artists\")\n        if isinstance(artists, list):\n            artist = \", \".join([a.get(\"name\") for a in artists])\n        else:\n            # Yet another 'wrong' entry in the database:\n            # artists in custom_files was sometimes recorded as single value\n            # @TODO also remove once way in the past? (2023-01-31)\n            artist = artists\n    elif music.get(\"artist\") is not None:\n        artist = music.get(\"artist\")\n    elif music.get(\"Artist\") is not None:  # pragma: no cover\n        # Uppercase is a hack needed for Jun 2021 since there is a 'wrong' entry\n        # in the database. Going forward the record will be available as 'artist'\n        # in lowercase.\n        # @TODO remove once is waaaay in the past\n        artist = music.get(\"Artist\")\n    return artist\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_csv","title":"<code>get_csv(data, station_name='')</code>","text":"<p>Create SUISA compatible csv data.</p> <pre><code>data: To data to create csv from\nstation_name: Default station name for output\n</code></pre> <pre><code>csv: The converted data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_csv(data: dict, station_name: str = \"\") -&gt; str:\n    \"\"\"Create SUISA compatible csv data.\n\n    Arguments:\n    ---------\n        data: To data to create csv from\n        station_name: Default station name for output\n\n    Returns:\n    -------\n        csv: The converted data\n\n    \"\"\"\n    header = [\n        \"Titel\",\n        \"Komponist\",\n        \"Interpret\",\n        \"Interpreten-Info\",\n        \"Sender\",\n        \"Sendedatum\",\n        \"Sendedauer\",\n        \"Sendezeit\",\n        \"Werkverzeichnisangaben\",\n        \"ISRC\",\n        \"Label\",\n        \"CD ID / Katalog-Nummer\",\n        \"Aufnahmedatum\",\n        \"Aufnahmeland\",\n        \"Erstver\u00f6ffentlichungsdatum\",\n        \"Titel des Tontr\u00e4gers (Albumtitel)\",\n        \"Autor Text\",\n        \"Track Nummer\",\n        \"Genre\",\n        \"Programm\",\n        \"Bestellnummer\",\n        \"Marke\",\n        \"Label Code\",\n        \"EAN/GTIN\",\n        \"Identifikationsnummer\",\n    ]\n    csv = StringIO()\n    csv_writer = writer(csv, dialect=\"excel\")\n    csv_writer.writerow(header)\n\n    for entry in tqdm(data, desc=\"preparing tracks for report\"):\n        metadata = entry.get(\"metadata\")\n        # parse timestamp\n        timestamp = datetime.strptime(metadata.get(\"timestamp_local\"), ACRClient.TS_FMT)  # noqa: DTZ007\n\n        ts_date = timestamp.strftime(\"%Y%m%d\")\n        ts_time = timestamp.strftime(\"%H:%M:%S\")\n        hours, remainder = divmod(metadata.get(\"played_duration\"), 60 * 60)\n        minutes, seconds = divmod(remainder, 60)\n        # required format of duration field: hh:mm:ss\n        duration = f\"{hours:02}:{minutes:02}:{seconds:02}\"\n\n        try:\n            music = metadata.get(\"music\")[0]\n        except TypeError:\n            music = metadata.get(\"custom_files\")[0]\n        title = music.get(\"title\")\n\n        artist = get_artist(music)\n\n        composer = \", \".join(music.get(\"contributors\", {}).get(\"composers\", \"\"))\n        works_composer = \", \".join(\n            [\n                c[\"name\"]\n                for c in [\n                    item\n                    for sublist in [w[\"creators\"] for w in music.get(\"works\", [])]\n                    for item in sublist\n                ]\n                if c.get(\"role\", \"\") in [\"C\", \"Composer\", \"W\", \"Writer\"]\n            ],\n        )\n        if works_composer and (not composer or composer == artist):\n            composer = works_composer\n\n        isrc = get_isrc(music)\n        label = music.get(\"label\")\n\n        # load some \"best-effort\" fields\n        album = music.get(\"album\", \"\")\n        # it's a dict if it's from the ACRCloud bucket, a string if from a custom bucket\n        if isinstance(album, dict):\n            album = album.get(\"name\", \"\")\n        upc = music.get(\"external_ids\", {}).get(\"upc\", \"\")\n        release_date = funge_release_date(music.get(\"release_date\", \"\"))\n\n        # cridlib only supports timezone-aware datetime values, so we convert one\n        timestamp_utc = pytz.utc.localize(\n            datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n        )\n        # we include the acrid in our CRID so we know about the data's provenience\n        # in case any questions about the data we delivered are asked\n        acrid = music.get(\"acrid\")\n        local_id = cridlib.get(timestamp=timestamp_utc, fragment=f\"acrid={acrid}\")\n\n        csv_writer.writerow(\n            [\n                title,\n                composer,\n                artist,\n                \"\",  # Interpreten-Info\n                station_name,\n                ts_date,\n                duration,\n                ts_time,\n                \"\",  # Werkverzeichnisangaben\n                isrc,\n                label,\n                \"\",  # CD ID / Katalog-Nummer\n                \"\",  # Aufnahmedatum\n                \"\",  # Aufnahmeland\n                release_date,\n                album,\n                \"\",  # Autor Text\n                \"\",  # Track Nummer\n                \"\",  # Genre\n                \"\",  # Programm\n                \"\",  # Bestellnummer\n                \"\",  # Marke\n                \"\",  # Label Code\n                upc,\n                local_id,\n            ],\n        )\n    return csv.getvalue()\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_email_attachment","title":"<code>get_email_attachment(filename, filetype, data)</code>","text":"<p>Create attachment based on required filetype and data.</p> <pre><code>filename: The filename of the attachment\nfiletype: The filetype of the attachment\ndata: The attachment data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_email_attachment(filename: str, filetype: str, data: Any) -&gt; MIMEBase:  # noqa: ANN401\n    \"\"\"Create attachment based on required filetype and data.\n\n    Arguments:\n    ---------\n        filename: The filename of the attachment\n        filetype: The filetype of the attachment\n        data: The attachment data\n\n    \"\"\"\n    maintype: str\n    subtype: str\n    payload: str\n    if filetype == \"xlsx\":\n        maintype = \"application\"\n        subtype = \"vnd.ms-excel\"\n        payload = data.getvalue()\n    elif filetype == \"csv\":\n        maintype = \"text\"\n        subtype = \"csv\"\n        payload = data.encode(\"utf-8\")\n        part = MIMEBase(\"text\", \"csv\")\n\n    part = MIMEBase(maintype, subtype)\n    part.set_payload(payload)\n    encode_base64(part)\n    part.add_header(\n        \"Content-Disposition\", f\"attachment; filename={Path(filename).name}\"\n    )\n    return part\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_isrc","title":"<code>get_isrc(music)</code>","text":"<p>Get a valid ISRC from the music record or return an empty string.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_isrc(music: Any) -&gt; str:  # noqa: ANN401\n    \"\"\"Get a valid ISRC from the music record or return an empty string.\"\"\"\n    isrc = \"\"\n    if music.get(\"external_ids\", {}).get(\"isrc\"):\n        isrc = music.get(\"external_ids\").get(\"isrc\")\n    elif music.get(\"isrc\"):\n        isrc = music.get(\"isrc\")\n    # was a list with a singular entry for a while back in 2021\n    if isinstance(isrc, list):\n        isrc = isrc[0]\n    # some records contain the \"ISRC\" prefix that is described as legacy\n    # in the ISRC handbook from IFPI.\n    if isrc and isrc[:4] == \"ISRC\":\n        isrc = isrc[4:]\n    # take care of cases where the isrc is space delimited even though the\n    # record is technically wrong but happens often enough to warrant this\n    # hack.\n    if isrc:\n        isrc = isrc.replace(\" \", \"\")\n\n    if not ISRC.validate(isrc):\n        isrc = \"\"\n    return isrc\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_xlsx","title":"<code>get_xlsx(data, station_name='')</code>","text":"<p>Create SUISA compatible xlsx data.</p> <pre><code>data: The data to create xlsx from\nstation_name: Default station name for output\n</code></pre> <pre><code>xlsx: The converted data as BytesIO object\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_xlsx(data: Any, station_name: str = \"\") -&gt; BytesIO:  # noqa: ANN401\n    \"\"\"Create SUISA compatible xlsx data.\n\n    Arguments:\n    ---------\n        data: The data to create xlsx from\n        station_name: Default station name for output\n\n    Returns:\n    -------\n        xlsx: The converted data as BytesIO object\n\n    \"\"\"\n    csv = get_csv(data, station_name=station_name)\n    csv_reader = reader(StringIO(csv))\n\n    xlsx = BytesIO()\n    workbook: Workbook = Workbook()\n    if not workbook.active:  # pragma: no cover\n        raise RuntimeError\n    worksheet: Worksheet = workbook.active  # type: ignore[assignment]\n\n    for row in csv_reader:\n        worksheet.append(row)\n\n    # the columns that should be styled as required (grey background)\n    required_columns = [\n        \"Titel\",\n        \"Komponist\",\n        \"Interpret\",\n        \"Sendedatum\",\n        \"Sendedauer\",\n        \"Sendezeit\",\n        \"ISRC\",\n        \"Label\",\n        \"Label Code\",\n        \"Identifikationsnummer\",\n    ]\n    font = Font(name=\"Calibri\", bold=True, size=12)\n    side = Side(border_style=\"thick\", color=\"000000\")\n    border = Border(top=side, left=side, right=side, bottom=side)\n    fill = PatternFill(\"solid\", bgColor=\"d9d9d9\", fgColor=\"d9d9d9\")\n    for cell in worksheet[1]:  # xlsx is 1-indexed\n        cell.font = font\n        cell.border = border\n        if cell.value in required_columns:\n            cell.fill = fill\n\n    # Try to approximate the required width by finding the longest values per column\n    dims: dict[str, int] = {}\n    for row in worksheet.rows:  # type: ignore[assignment]\n        for cell in row:  # type: ignore[assignment]\n            if cell.value:\n                dims[cell.column_letter] = max(\n                    (dims.get(cell.column_letter, 0), len(str(cell.value))),\n                )\n    # apply estimated width to each column\n    padding = 3\n    for col, value in dims.items():\n        worksheet.column_dimensions[col].width = value + padding\n\n    workbook.save(xlsx)\n    return xlsx\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.main","title":"<code>main()</code>","text":"<p>Entrypoint for SUISA Sendemeldung .</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def main() -&gt; None:  # pragma: no cover\n    \"\"\"Entrypoint for SUISA Sendemeldung .\"\"\"\n    default_config_file: str = Path(__file__).name.replace(\".py\", \".conf\")\n    # config file in /etc gets overriden by the one in $HOME which gets overriden by the\n    # one in the current directory\n    default_config_files = [\n        str(Path(\"/etc\") / default_config_file),\n        str(Path(\"~\").expanduser() / default_config_file),\n        default_config_file,\n    ]\n    parser = ArgumentParser(\n        default_config_files=default_config_files,\n        description=\"ACRCloud client for SUISA reporting @ RaBe.\",\n    )\n    args = get_arguments(parser, sys.argv[1:])\n\n    start_date, end_date = parse_date(args)\n    filename = parse_filename(args, start_date)\n\n    client = ACRClient(bearer_token=args.bearer_token)\n    data = client.get_interval_data(\n        args.project_id,\n        args.stream_id,\n        start_date,\n        end_date,\n        timezone=args.timezone,\n    )\n    data = merge_duplicates(data)\n    if args.filetype == \"xlsx\":\n        data = get_xlsx(data, station_name=args.station_name)\n    elif args.filetype == \"csv\":\n        data = get_csv(data, station_name=args.station_name)\n    if args.email:\n        email_subject = Template(args.email_subject).substitute(\n            {\n                \"station_name\": args.station_name,\n                \"year\": format_date(start_date, format=\"yyyy\", locale=args.locale),\n                \"month\": format_date(start_date, format=\"MM\", locale=args.locale),\n            },\n        )\n        # generate body\n        text = Template(args.email_text).substitute(\n            {\n                \"station_name\": args.station_name,\n                \"month\": format_date(start_date, format=\"MMMM\", locale=args.locale),\n                \"year\": format_date(start_date, format=\"yyyy\", locale=args.locale),\n                \"previous_year\": format_date(\n                    start_date - timedelta(days=365),\n                    format=\"yyyy\",\n                    locale=args.locale,\n                ),\n                \"in_three_months\": format_date(\n                    datetime.now() + relativedelta(months=+3),  # noqa: DTZ005\n                    format=\"long\",\n                    locale=args.locale,\n                ),\n                \"responsible_email\": args.responsible_email,\n                \"email_footer\": args.email_footer,\n            },\n        )\n        msg = create_message(\n            args.email_from,\n            args.email_to,\n            email_subject,\n            text,\n            filename,\n            args.filetype,\n            data,\n            cc=args.email_cc,\n            bcc=args.email_bcc,\n        )\n        send_message(\n            msg,\n            server=args.email_server,\n            login=args.email_login,\n            password=args.email_pass,\n        )\n    if args.file and args.filetype == \"xlsx\":\n        write_xlsx(filename, data)\n    elif args.file and args.filetype == \"csv\":\n        write_csv(filename, data)\n    if args.stdout and args.filetype == \"csv\":\n        print(data)  # noqa: T201\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.merge_duplicates","title":"<code>merge_duplicates(data)</code>","text":"<p>Merge consecutive entries into one if they are duplicates.</p> <pre><code>data: The data provided by ACRClient\n</code></pre> <pre><code>data: The processed data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def merge_duplicates(data: Any) -&gt; Any:  # noqa: ANN401\n    \"\"\"Merge consecutive entries into one if they are duplicates.\n\n    Arguments:\n    ---------\n        data: The data provided by ACRClient\n\n    Returns:\n    -------\n        data: The processed data\n\n    \"\"\"\n    prev = data[0]\n    mark = []\n    for entry in data[1:]:\n        if check_duplicate(prev, entry):\n            prev[\"metadata\"][\"played_duration\"] = (\n                prev[\"metadata\"][\"played_duration\"]\n                + entry[\"metadata\"][\"played_duration\"]\n            )\n            # mark entry for removal\n            mark.append(entry)\n        else:\n            prev = entry\n    # remove marked entries\n    for entry in mark:\n        data.remove(entry)\n    return data\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.parse_date","title":"<code>parse_date(args)</code>","text":"<p>Parse date from args.</p> <pre><code>args: the arguments provided to the script\n</code></pre> <pre><code>start_date: the start date of the requested interval\nend_date: the end date of the requested interval\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def parse_date(args: ArgparseNamespace) -&gt; tuple[date, date]:\n    \"\"\"Parse date from args.\n\n    Arguments:\n    ---------\n        args: the arguments provided to the script\n\n    Returns:\n    -------\n        start_date: the start date of the requested interval\n        end_date: the end date of the requested interval\n\n    \"\"\"\n    # date parsing logic\n    if args.last_month:\n        today = date.today()  # noqa: DTZ011\n        # get first of this month\n        this_month = today.replace(day=1)\n        # last day of last month = first day of this month - 1 day\n        end_date = this_month - timedelta(days=1)\n        start_date = end_date.replace(day=1)\n    else:\n        if args.end_date:\n            end_date = datetime.strptime(args.end_date, \"%Y-%m-%d\").date()  # noqa: DTZ007\n        else:\n            # if no end_date was set, default to today\n            end_date = date.today()  # noqa: DTZ011\n        if args.start_date:\n            start_date = datetime.strptime(args.start_date, \"%Y-%m-%d\").date()  # noqa: DTZ007\n        else:\n            # if no start_date was set, default to 30 days before end_date\n            start_date = end_date - timedelta(days=30)\n    return start_date, end_date\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.parse_filename","title":"<code>parse_filename(args, start_date)</code>","text":"<p>Parse filename from args and start_date.</p> <pre><code>args: the arguments provided to the script\nstart_date: start of reporting period\n</code></pre> <pre><code>filename: the filename to use for the csv data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def parse_filename(args: ArgparseNamespace, start_date: date) -&gt; str:\n    \"\"\"Parse filename from args and start_date.\n\n    Arguments:\n    ---------\n        args: the arguments provided to the script\n        start_date: start of reporting period\n\n    Returns:\n    -------\n        filename: the filename to use for the csv data\n\n    \"\"\"\n    if args.filename:\n        filename = args.filename\n    # depending on date args either append the month or the start_date\n    elif args.last_month:\n        date_part = f\"{start_date.strftime('%Y')}_{start_date.strftime('%m')}\"\n        filename = f\"{args.station_name_short}_{date_part}.{args.filetype}\"\n    else:\n        filename = (\n            f\"{args.station_name_short}_\"\n            f\"{start_date.strftime('%Y-%m-%d')}.{args.filetype}\"\n        )\n    return filename\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.send_message","title":"<code>send_message(msg, server='127.0.0.1', login=None, password=None)</code>","text":"<p>Send email.</p> <pre><code>msg: The message to send (an email.messag.Message object)\nserver: The SMTP server to use to send the email.\nlogin: The username for `sender`@`server`.\npassword: The password for `sender`@`server`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def send_message(\n    msg: MIMEMultipart,\n    server: str = \"127.0.0.1\",\n    login: str | None = None,\n    password: str | None = None,\n) -&gt; None:\n    \"\"\"Send email.\n\n    Arguments:\n    ---------\n        msg: The message to send (an email.messag.Message object)\n        server: The SMTP server to use to send the email.\n        login: The username for `sender`@`server`.\n        password: The password for `sender`@`server`.\n\n    \"\"\"\n    with SMTP(server) as smtp:\n        smtp.starttls()\n        if password:\n            if login:\n                smtp.login(login, password)\n            else:\n                smtp.login(msg[\"From\"], password)\n        smtp.send_message(msg)\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.validate_arguments","title":"<code>validate_arguments(parser, args)</code>","text":"<p>Validate the arguments provided to the script.</p> <p>After this function we are sure that there are no conflicts in the arguments.</p> <pre><code>parser: the ArgumentParser to use for throwing errors\nargs: the arguments to validate\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def validate_arguments(parser: ArgumentParser, args: ArgparseNamespace) -&gt; None:\n    \"\"\"Validate the arguments provided to the script.\n\n    After this function we are sure that there are no conflicts in the arguments.\n\n    Arguments:\n    ---------\n        parser: the ArgumentParser to use for throwing errors\n        args: the arguments to validate\n\n    \"\"\"\n    msgs = []\n    # check length of bearer_token\n    if not len(args.bearer_token) &gt;= _ACRTOKEN_MAXLEN:\n        msgs.append(\n            \"\".join(\n                (\n                    \"wrong format on bearer_token, \"\n                    \"expected larger than 32 characters \"\n                    f\"but got {len(args.bearer_token)}\"\n                ),\n            ),\n        )\n    # check length of stream_id\n    if len(args.stream_id) not in [9, 10]:\n        msgs.append(\n            (\n                \"wrong format on stream_id, \"\n                f\"expected 9 or 10 characters but got {len(args.stream_id)}\"\n            ),\n        )\n    # one output option has to be set\n    if not (args.file or args.email or args.stdout):\n        msgs.append(\n            \"no output option has been set, specify one of --file, --email or --stdout\",\n        )\n    # xlsx cannot be printed to stdout\n    if args.stdout and args.filetype == \"xlsx\":\n        msgs.append(\"xlsx cannot be printed to stdout, please set --filetype to csv\")\n    # last_month is in conflict with start_date and end_date\n    if args.last_month and (args.start_date or args.end_date):\n        msgs.append(\"argument --last_month not allowed with --start_date or --end_date\")\n    # exit if there are error messages\n    if msgs:\n        parser.error(\"\\n- \" + \"\\n- \".join(msgs))\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.write_csv","title":"<code>write_csv(filename, csv)</code>","text":"<p>Write contents of <code>csv</code> to file.</p> <pre><code>filename: The file to write to.\ncsv: The data to write to `filename`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def write_csv(filename: str, csv: str) -&gt; None:  # pragma: no cover\n    \"\"\"Write contents of `csv` to file.\n\n    Arguments:\n    ---------\n        filename: The file to write to.\n        csv: The data to write to `filename`.\n\n    \"\"\"\n    with Path(filename).open(\"w\", encoding=\"utf-8\") as csvfile:\n        csvfile.write(csv)\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.write_xlsx","title":"<code>write_xlsx(filename, xlsx)</code>","text":"<p>Write contents of <code>xlsx</code> to file.</p> <pre><code>filename: The file to write to.\nxlsx: The data to write to `filename`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def write_xlsx(filename: str, xlsx: BytesIO) -&gt; None:  # pragma: no cover\n    \"\"\"Write contents of `xlsx` to file.\n\n    Arguments:\n    ---------\n        filename: The file to write to.\n        xlsx: The data to write to `filename`.\n\n    \"\"\"\n    with Path(filename).open(\"wb\") as xlsxfile:\n        xlsxfile.write(xlsx.getvalue())\n</code></pre>"}]}