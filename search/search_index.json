{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"suisa_sendemeldung","text":"<p>ACRCloud client that fetches data on our playout history and formats them in a CSV file format containing the data (like Track, Title and ISRC) requested by SUISA. Also takes care of sending the report to SUISA via email for hands-off operations.</p>"},{"location":"#usage","title":"Usage","text":"<p>We provide the SUISA Sendmeldung script as a container image or as a python package.</p> <p>These usage instructions show how to install the script and how to configure it. There are different ways to run it at a schedule. We recommend using systemd-timers an example to do so is provided in the <code>etc/</code> directory.</p> <p>To output the scripts usage information, check out it's <code>--help</code> output:</p> <pre><code># Using Podman\npodman run --rm -ti ghcr.io/radiorabe/suisasendemeldung:latest suisa_sendemeldung --help\n\n# Using Docker\ndocker run --rm -ti ghcr.io/radiorabe/suisasendemeldung:latest suisa_sendemeldung --help\n</code></pre> <p>While we recommend running the script in it's container, you can also install the script in any python environment using pip.</p> <p>We recommend using a dedicated venv for running the script should you go down this route:</p> <pre><code>python -mvenv .venv\n. .venv/bin/activate\n\npip install suisa_sendemeldung\n\n# Output usage after installation\nsuisa_sendemeldung\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>You can configure this script with a configuration file (default is <code>suisa_sendemeldung.toml</code>), environment variables, or command line arguments.</p> <p>Command line arguments override environment variables which themselves override settings in the configuration file.</p>"},{"location":"#configuration-file","title":"Configuration file","text":"<p>The configuration files will be evaluated in the following order (last takes precedence over first):</p> <ol> <li><code>/etc/suisa_sendemeldung.toml</code></li> <li><code>./suisa_sendemeldung.toml</code></li> </ol> <p>For details on how to set configuration values, have a look at suisa_sendemeldung.toml.</p>"},{"location":"#environment-variables","title":"Environment variables","text":"<p>Environment variables can also be passed as options. The relevant variables are listed in the output of <code>suisa_sendemeldung --help</code>.</p> <p>For example run the script as follows:</p> <pre><code>podman run --rm -ti -e SENDEMELDUNG_ACR_BEARER_TOKEN=abcdefghijklmnopqrstuvwxyzabcdef -e SENDEMELDUNG_ACR_STREAM_ID=a-bcdefgh -e SENDEMELDUNG_OUTPUT=stdout ghcr.io/radiorabe/suisasendemeldung:latest suisa_sendemeldung\n</code></pre>"},{"location":"#command-line-switches","title":"Command line switches","text":"<p>As documented in Usage, you can also pass in options on the command line as arguments. Simply run the script as follows:</p> <pre><code>podman run --rm -ti ghcr.io/radiorabe/suisasendemeldung:latest suisa_sendemeldung --acr-bearer-token=abcdefghijklmnopqrstuvwxyzabcdef --acr-stream-id=a-bcdefgh --output=stdout\n</code></pre>"},{"location":"#support","title":"Support","text":"<p>We support users where is reasonably possible on a best-efforts base.</p> <p>The following versions of SUISA Sendemeldung are actively supported.</p> Version Supported Supported GST Python Version Description 0.x (\u2705) GST 2020 Developed during the GST lifetime, internal use at RaBe 1.x \u2705 GST 2026 &gt;=3.12 Cleanup and first release with features for external use <ul> <li>old versions are supported on a case by case base if we need to regenerate old reports</li> </ul>"},{"location":"#upgrading","title":"Upgrading","text":""},{"location":"#upgrade-from-0x-to-10","title":"Upgrade from 0.x to 1.0","text":"<ul> <li>The config file was renamed from <code>suisa_sendemeldung.conf</code> to <code>suisa_sendemeldung.toml</code></li> <li>The config file format has been changed from an <code>ini</code> style file to TOML.</li> <li>The command line arguments have been reworked to match the new config file format, check <code>suisa_sendemeldung --help</code>. for the new flags.</li> <li>The \"last 30 days from today\" mode has been dropped, call the script with <code>--by-date</code>, <code>--date-start</code> and <code>--date-end</code>.</li> </ul>"},{"location":"#development","title":"Development","text":"<p>Snapshot testing is used to test the help output, you can update the snapshots like so: <pre><code>poetry run pytest -- --snapshot-update\n</code></pre></p>"},{"location":"#release-management","title":"Release Management","text":"<p>At RaBe we run the script on the first and 14th of each month. Matching this we only release new versions of the script in the second half of each month.</p> <p>The CI/CD setup uses semantic commit messages following the conventional commits standard. There is a GitHub Action in .github/workflows/semantic-release.yaml that uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p> <p>Once a commit has landed on the <code>main</code> branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses twine to publish the package to pypi. The <code>release.yaml</code> action also takes care of pushing a container image to GitHub Packages.</p>"},{"location":"reference/acrclient/","title":"Acrclient","text":"<p>module containing the ACRCloud client.</p>"},{"location":"reference/acrclient/#acrclient.ACRClient","title":"<code>ACRClient</code>","text":"<p>               Bases: <code>Client</code></p> <p>ACRCloud client wrapper to fetch metadata.</p> <pre><code>bearer_token: The bearer token for ACRCloud.\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>class ACRClient(Client):\n    \"\"\"ACRCloud client wrapper to fetch metadata.\n\n    Arguments:\n    ---------\n        bearer_token: The bearer token for ACRCloud.\n\n    \"\"\"\n\n    # format of timestamp in api answer\n    TS_FMT = \"%Y-%m-%d %H:%M:%S\"\n    # timezone of ACRCloud\n    ACR_TIMEZONE = \"UTC\"\n\n    def __init__(\n        self: Self, bearer_token: str, base_url: str = \"https://eu-api-v2.acrcloud.com\"\n    ) -&gt; None:\n        \"\"\"Init subclass with default_date.\"\"\"\n        super().__init__(bearer_token=bearer_token, base_url=base_url)\n        self.default_date: date = date.today() - timedelta(days=1)  # noqa: DTZ011\n\n    def get_data(\n        self: Self,\n        project_id: int,\n        stream_id: str,\n        requested_date: date | None = None,\n        timezone: str = ACR_TIMEZONE,\n    ) -&gt; Any:  # noqa: ANN401\n        \"\"\"Fetch metadata from ACRCloud for `stream_id`.\n\n        Arguments:\n        ---------\n            project_id: The Project ID of the stream.\n            stream_id: The ID of the stream.\n            requested_date: The date of the entries you want (default: yesterday).\n            timezone: The timezone to use for localization.\n\n        Returns:\n        -------\n            json: The ACR data from date\n\n        \"\"\"\n        if requested_date is None:\n            requested_date = self.default_date\n        data = self.get_bm_cs_projects_results(\n            project_id=project_id,\n            stream_id=stream_id,\n            params=GetBmCsProjectsResultsParams(\n                type=\"day\",\n                date=requested_date.strftime(\"%Y%m%d\"),\n            ),\n        )\n        for entry in data:\n            metadata = entry.get(\"metadata\")\n            ts_utc = pytz.utc.localize(\n                datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n            )\n            ts_local = ts_utc.astimezone(pytz.timezone(timezone))\n            metadata.update({\"timestamp_local\": ts_local.strftime(ACRClient.TS_FMT)})\n\n        return data\n\n    def get_interval_data(  # noqa: ANN201\n        self: Self,\n        project_id: int,\n        stream_id: str,\n        start: date,\n        end: date,\n        timezone: str = ACR_TIMEZONE,\n    ):\n        \"\"\"Get data specified by interval from start to end.\n\n        Arguments:\n        ---------\n            project_id: The ID of the project.\n            stream_id: The ID of the stream.\n            start: The start date of the interval.\n            end: The end date of the interval.\n            timezone (optional): will be passed to `get_data()`.\n\n        Returns:\n        -------\n            json: The ACR data from start to end.\n\n        \"\"\"\n        trim = False\n        # if we have to localize the timestamps we may need more data\n        if timezone != ACRClient.ACR_TIMEZONE:\n            # compute utc offset\n            offset = pytz.timezone(timezone).utcoffset(datetime.now())  # noqa: DTZ005\n            # decrease start by 1 day if we're ahead of utc\n            if offset &gt; timedelta(seconds=1):\n                computed_start = start - timedelta(days=1)\n                computed_end = end\n                trim = True\n            # increase end by 1 day if we're behind of utc\n            elif offset &lt; timedelta(seconds=1):\n                computed_start = start\n                computed_end = end + timedelta(days=1)\n                trim = True\n        else:\n            computed_start = start\n            computed_end = end\n\n        dates = []\n        ptr = computed_start\n        while ptr &lt;= computed_end:\n            dates.append(ptr)\n            ptr += timedelta(days=1)\n        data = []\n        # make the prefix longer by this amount so tqdm lines up with\n        # the one in the main code\n        ljust_amount: int = 27\n        for ptr in tqdm(dates, desc=\"load ACRCloud data\".ljust(ljust_amount)):\n            data += self.get_data(\n                project_id,\n                stream_id,\n                requested_date=ptr,\n                timezone=timezone,\n            )\n\n        # if timestamps are localized we will have to removed the unneeded entries.\n        if trim:\n            for entry in reversed(data):\n                metadata = entry.get(\"metadata\")\n                timestamp = metadata.get(\"timestamp_local\")\n                timestamp_date = datetime.strptime(  # noqa: DTZ007\n                    timestamp, ACRClient.TS_FMT\n                ).date()\n                if timestamp_date &lt; start or timestamp_date &gt; end:\n                    data.remove(entry)\n\n        return data\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.__init__","title":"<code>__init__(bearer_token, base_url='https://eu-api-v2.acrcloud.com')</code>","text":"<p>Init subclass with default_date.</p> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def __init__(\n    self: Self, bearer_token: str, base_url: str = \"https://eu-api-v2.acrcloud.com\"\n) -&gt; None:\n    \"\"\"Init subclass with default_date.\"\"\"\n    super().__init__(bearer_token=bearer_token, base_url=base_url)\n    self.default_date: date = date.today() - timedelta(days=1)  # noqa: DTZ011\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.get_data","title":"<code>get_data(project_id, stream_id, requested_date=None, timezone=ACR_TIMEZONE)</code>","text":"<p>Fetch metadata from ACRCloud for <code>stream_id</code>.</p> <pre><code>project_id: The Project ID of the stream.\nstream_id: The ID of the stream.\nrequested_date: The date of the entries you want (default: yesterday).\ntimezone: The timezone to use for localization.\n</code></pre> <pre><code>json: The ACR data from date\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def get_data(\n    self: Self,\n    project_id: int,\n    stream_id: str,\n    requested_date: date | None = None,\n    timezone: str = ACR_TIMEZONE,\n) -&gt; Any:  # noqa: ANN401\n    \"\"\"Fetch metadata from ACRCloud for `stream_id`.\n\n    Arguments:\n    ---------\n        project_id: The Project ID of the stream.\n        stream_id: The ID of the stream.\n        requested_date: The date of the entries you want (default: yesterday).\n        timezone: The timezone to use for localization.\n\n    Returns:\n    -------\n        json: The ACR data from date\n\n    \"\"\"\n    if requested_date is None:\n        requested_date = self.default_date\n    data = self.get_bm_cs_projects_results(\n        project_id=project_id,\n        stream_id=stream_id,\n        params=GetBmCsProjectsResultsParams(\n            type=\"day\",\n            date=requested_date.strftime(\"%Y%m%d\"),\n        ),\n    )\n    for entry in data:\n        metadata = entry.get(\"metadata\")\n        ts_utc = pytz.utc.localize(\n            datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n        )\n        ts_local = ts_utc.astimezone(pytz.timezone(timezone))\n        metadata.update({\"timestamp_local\": ts_local.strftime(ACRClient.TS_FMT)})\n\n    return data\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.get_interval_data","title":"<code>get_interval_data(project_id, stream_id, start, end, timezone=ACR_TIMEZONE)</code>","text":"<p>Get data specified by interval from start to end.</p> <pre><code>project_id: The ID of the project.\nstream_id: The ID of the stream.\nstart: The start date of the interval.\nend: The end date of the interval.\ntimezone (optional): will be passed to `get_data()`.\n</code></pre> <pre><code>json: The ACR data from start to end.\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def get_interval_data(  # noqa: ANN201\n    self: Self,\n    project_id: int,\n    stream_id: str,\n    start: date,\n    end: date,\n    timezone: str = ACR_TIMEZONE,\n):\n    \"\"\"Get data specified by interval from start to end.\n\n    Arguments:\n    ---------\n        project_id: The ID of the project.\n        stream_id: The ID of the stream.\n        start: The start date of the interval.\n        end: The end date of the interval.\n        timezone (optional): will be passed to `get_data()`.\n\n    Returns:\n    -------\n        json: The ACR data from start to end.\n\n    \"\"\"\n    trim = False\n    # if we have to localize the timestamps we may need more data\n    if timezone != ACRClient.ACR_TIMEZONE:\n        # compute utc offset\n        offset = pytz.timezone(timezone).utcoffset(datetime.now())  # noqa: DTZ005\n        # decrease start by 1 day if we're ahead of utc\n        if offset &gt; timedelta(seconds=1):\n            computed_start = start - timedelta(days=1)\n            computed_end = end\n            trim = True\n        # increase end by 1 day if we're behind of utc\n        elif offset &lt; timedelta(seconds=1):\n            computed_start = start\n            computed_end = end + timedelta(days=1)\n            trim = True\n    else:\n        computed_start = start\n        computed_end = end\n\n    dates = []\n    ptr = computed_start\n    while ptr &lt;= computed_end:\n        dates.append(ptr)\n        ptr += timedelta(days=1)\n    data = []\n    # make the prefix longer by this amount so tqdm lines up with\n    # the one in the main code\n    ljust_amount: int = 27\n    for ptr in tqdm(dates, desc=\"load ACRCloud data\".ljust(ljust_amount)):\n        data += self.get_data(\n            project_id,\n            stream_id,\n            requested_date=ptr,\n            timezone=timezone,\n        )\n\n    # if timestamps are localized we will have to removed the unneeded entries.\n    if trim:\n        for entry in reversed(data):\n            metadata = entry.get(\"metadata\")\n            timestamp = metadata.get(\"timestamp_local\")\n            timestamp_date = datetime.strptime(  # noqa: DTZ007\n                timestamp, ACRClient.TS_FMT\n            ).date()\n            if timestamp_date &lt; start or timestamp_date &gt; end:\n                data.remove(entry)\n\n    return data\n</code></pre>"},{"location":"reference/settings/","title":"Settings","text":"<p>Settings for SUISA Sendemeldung.</p>"},{"location":"reference/settings/#settings.ACR","title":"<code>ACR</code>","text":"<p>ACRCloud configuration</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass ACR:\n    \"\"\"ACRCloud configuration\"\"\"  # noqa: D400, D415\n\n    bearer_token: str = ts.secret(\n        help=\"Bearer token for ACRCloud API access\",\n        validator=validators.min_len(32),\n    )\n    project_id: int = ts.option(\n        help=\"Id of the project in ACRCloud\",\n        validator=validators.ge(0),\n    )\n    stream_id: str = ts.option(\n        help=\"Id of the stream in ACRCloud\",\n        validator=validators.min_len(9),\n    )\n</code></pre>"},{"location":"reference/settings/#settings.EmailSettings","title":"<code>EmailSettings</code>","text":"<p>Email configuration</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass EmailSettings:\n    \"\"\"Email configuration\"\"\"  # noqa: D400, D415\n\n    sender: str = ts.option(help=\"the sender of the email\", default=\"\")\n    to: str = ts.option(help=\"the recipients of the email\", default=\"\")\n    server: str = ts.option(help=\"the smtp server to send the mail with\", default=\"\")\n    port: int = ts.option(help=\"the port of the smtp server\", default=587)\n    username: str = ts.option(\n        help=\"the username to logon to the smtp server (default: email_from)\",\n        default=\"\",\n    )\n    password: str = ts.secret(help=\"the password for the smtp server\", default=\"\")\n    responsible_email: str = ts.option(\n        help=\"Used to hint whom to contact in the emails text.\", default=\"\"\n    )\n    cc: str = ts.option(help=\"the cc recipients of the email\", default=\"\")\n    bcc: str = ts.option(help=\"the bcc recipients of the email\", default=\"\")\n    subject: str = ts.option(\n        help=\"\"\"\n        Template for subject of the email.\n\n        Placeholders are $station_name, $year and $month.\n        \"\"\",\n        default=\"SUISA Sendemeldung von $station_name f\u00fcr $year-$month\",\n        click={\"show_default\": False},\n    )\n    text: str = ts.option(\n        help=\"\"\"\n        Template for email text.\n\n        Placeholders are $station_name, $month, $year, $previous_year,\n        $responsible_email, and $email_footer.\n        \"\"\",\n        default=_EMAIL_TEMPLATE,\n        click={\"show_default\": False},\n    )\n    footer: str = ts.option(\n        help=\"Footer for the Email\",\n        default=\"Email generated by &lt;https://github.com/radiorabe/suisa_sendemeldung&gt;\",\n        click={\"show_default\": False},\n    )\n</code></pre>"},{"location":"reference/settings/#settings.FileFormat","title":"<code>FileFormat</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>File formats for the report.</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>class FileFormat(StrEnum):\n    \"\"\"File formats for the report.\"\"\"\n\n    xlsx = \"xlsx\"\n    csv = \"csv\"\n</code></pre>"},{"location":"reference/settings/#settings.FileSettings","title":"<code>FileSettings</code>","text":"<p>File configuration</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass FileSettings:\n    \"\"\"File configuration\"\"\"  # noqa: D400, D415\n\n    format: FileFormat = ts.option(default=FileFormat.xlsx)\n    path: str = ts.option(default=\"\")\n</code></pre>"},{"location":"reference/settings/#settings.IdentifierMode","title":"<code>IdentifierMode</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Modes for generating the identifier in the report.</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>class IdentifierMode(StrEnum):\n    \"\"\"Modes for generating the identifier in the report.\"\"\"\n\n    local = \"local\"\n    cridlib = \"cridlib\"\n</code></pre>"},{"location":"reference/settings/#settings.LocalizationSettings","title":"<code>LocalizationSettings</code>","text":"<p>Localization configuration</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass LocalizationSettings:\n    \"\"\"Localization configuration\"\"\"  # noqa: D400, D415\n\n    timezone: str = \"Europe/Zurich\"\n    locale: str = \"de_CH\"\n</code></pre>"},{"location":"reference/settings/#settings.OutputMode","title":"<code>OutputMode</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Output modes for the report.</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>class OutputMode(StrEnum):\n    \"\"\"Output modes for the report.\"\"\"\n\n    file = \"file\"\n    email = \"email\"\n    stdout = \"stdout\"\n</code></pre>"},{"location":"reference/settings/#settings.RangeSettings","title":"<code>RangeSettings</code>","text":"<p>Configure the range of the report</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass RangeSettings:\n    \"\"\"Configure the range of the report\"\"\"  # noqa: D400, D415\n\n    last_month: bool = ts.option(\n        help=\"\"\"\n        The default is to generate ia report for the full last month,\n        use --by-date with --date-start and --date-end for a range\n        \"\"\",\n        default=True,\n        click={\"param_decls\": (\"--last-month/--by-date\",)},\n    )\n    start: str = ts.option(\n        help=\"The start date of the interval in format YYYY-MM-DD [env var: SENDEMELDUNG_DATE_START; default: now - 30d]\",  # noqa: E501\n        default=\"\",\n        click={\"show_default\": False, \"show_envvar\": False},\n    )\n    end: str = ts.option(\n        help=\"The end date of the interval in format YYYY-MM-DD [env var: SENDEMELDUNG_DATE_END; default: now]\",  # noqa: E501\n        default=\"\",\n        click={\"show_default\": False, \"show_envvar\": False},\n    )\n</code></pre>"},{"location":"reference/settings/#settings.Settings","title":"<code>Settings</code>","text":"<p>Settings</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass Settings:\n    \"\"\"Settings\"\"\"  # noqa: D400, D415\n\n    output: OutputMode = ts.option(\n        help=\"How to output the report\", default=OutputMode.file\n    )\n    crid_mode: IdentifierMode = ts.option(\n        help=\"How to generate the identifier in the report\",\n        default=IdentifierMode.local,\n    )\n\n    acr: ACR = ts.option(default=None)\n    date: RangeSettings = ts.option(default=RangeSettings())\n    station: StationSettings = ts.option(default=StationSettings())\n    l10n: LocalizationSettings = ts.option(default=LocalizationSettings())\n    file: FileSettings = ts.option(default=FileSettings())\n    email: EmailSettings = ts.option(default=EmailSettings())\n</code></pre>"},{"location":"reference/settings/#settings.StationSettings","title":"<code>StationSettings</code>","text":"<p>Basic station information</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass StationSettings:\n    \"\"\"Basic station information\"\"\"  # noqa: D400, D415\n\n    name: str = ts.option(\n        help=\"Station name, used in output and emails\", default=\"Radio Bern RaBe\"\n    )\n    name_short: str = ts.option(\n        help=\"Shortname for station as used in filenames (locally and in attachment)\",\n        default=\"rabe\",\n    )\n</code></pre>"},{"location":"reference/suisa_sendemeldung/","title":"Suisa sendemeldung","text":"<p>SUISA Sendemeldung bugs SUISA with email once per month.</p> <p>Fetches data on our playout history and formats them in a CSV file format containing the data (like Track, Title and ISRC) requested by SUISA. Also takes care of sending the report to SUISA via email for hands-off operations.</p>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.check_duplicate","title":"<code>check_duplicate(entry_a, entry_b)</code>","text":"<p>Check if two entries are duplicates by checking their acrid in all music items.</p> <pre><code>entry_a: first entry\nentry_b: second entry\n</code></pre> <pre><code>True if the entries are duplicates, False otherwise\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def check_duplicate(entry_a: dict, entry_b: dict) -&gt; bool:\n    \"\"\"Check if two entries are duplicates by checking their acrid in all music items.\n\n    Arguments:\n    ---------\n        entry_a: first entry\n        entry_b: second entry\n\n    Returns:\n    -------\n        True if the entries are duplicates, False otherwise\n\n    \"\"\"\n    try:\n        entry_a = entry_a[\"metadata\"][\"music\"]\n    except KeyError:\n        entry_a = entry_a[\"metadata\"][\"custom_files\"]\n    try:\n        entry_b = entry_b[\"metadata\"][\"music\"]\n    except KeyError:\n        entry_b = entry_b[\"metadata\"][\"custom_files\"]\n    for music_a in entry_a:\n        for music_b in entry_b:\n            if music_a[\"acrid\"] == music_b[\"acrid\"]:\n                return True\n    return False\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.cli","title":"<code>cli(settings)</code>","text":"<p>SUISA Sendemeldung.</p> <p>Create and send playout reports to SUISA.</p> <p>The reports are based on data from ACRCloud.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>@click.command()\n@typed_settings.click_options(\n    Settings,\n    loaders=typed_settings.default_loaders(\n        \"sendemeldung\",\n        [\n            \"/etc/suisa_sendemeldung.toml\",\n            \"suisa_sendemeldung.toml\",\n        ],\n    ),\n    decorator_factory=OptionGroupFactory(),\n    show_envvars_in_help=True,\n)\ndef cli(settings: Settings) -&gt; None:  # pragma: no cover\n    \"\"\"SUISA Sendemeldung.\n\n    Create and send playout reports to SUISA.\n\n    The reports are based on data from ACRCloud.\n    \"\"\"\n    main(settings)\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.create_message","title":"<code>create_message(sender, recipient, subject, text, filename, filetype, data, cc=None, bcc=None)</code>","text":"<p>Create email message.</p> <pre><code>sender: The sender of the email. Login will be made with this user.\nrecipient: The recipient of the email. Can be a list.\nsubject: The subject of the email.\ntext: The body of the email.\nfilename: The filename of the attachment\nfiletype: The filetype of the attachment\ndata: The attachment data.\ncc: cc recipient\nbcc: bcc recipient\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def create_message(  # noqa: PLR0913\n    sender: str,\n    recipient: str,\n    subject: str,\n    text: str,\n    filename: str,\n    filetype: str,\n    data: BytesIO | str,\n    cc: str | None = None,\n    bcc: str | None = None,\n) -&gt; MIMEMultipart:\n    \"\"\"Create email message.\n\n    Arguments:\n    ---------\n        sender: The sender of the email. Login will be made with this user.\n        recipient: The recipient of the email. Can be a list.\n        subject: The subject of the email.\n        text: The body of the email.\n        filename: The filename of the attachment\n        filetype: The filetype of the attachment\n        data: The attachment data.\n        cc: cc recipient\n        bcc: bcc recipient\n\n    \"\"\"\n    msg = MIMEMultipart()\n    msg[\"From\"] = sender\n    msg[\"To\"] = recipient\n    if cc:\n        msg[\"Cc\"] = cc\n    if bcc:\n        msg[\"Bcc\"] = bcc\n    msg[\"Date\"] = formatdate(localtime=True)\n    msg[\"Subject\"] = subject\n    # set body\n    msg.attach(MIMEText(text))\n    msg.attach(get_email_attachment(filename, filetype, data))\n\n    return msg\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.funge_release_date","title":"<code>funge_release_date(release_date='')</code>","text":"<p>Make a release_date from ACR conform to what seems to be the spec.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def funge_release_date(release_date: str = \"\") -&gt; str:\n    \"\"\"Make a release_date from ACR conform to what seems to be the spec.\"\"\"\n    if len(release_date) == 10:  # noqa: PLR2004\n        # we can make it look like what suisa has in their examples if it's the\n        # right length\n        try:\n            return datetime.strptime(release_date, \"%Y-%m-%d\").strftime(\"%Y%m%d\")  # noqa: DTZ007\n        except ValueError:\n            return \"\"\n    # we discard other records since there is no way to convert records like a plain\n    # year into dd/mm/yyyy properly without further guidance from whomever ingests\n    # the data, in some cases this means we discard data that only contain a year\n    # since they dont have that amount of precision.\n    return \"\"\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_artist","title":"<code>get_artist(music)</code>","text":"<p>Get artist from a given dict.</p> <pre><code>music: music dict from API\n</code></pre> <pre><code>artist: string representing the artist\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_artist(music: dict) -&gt; str:\n    \"\"\"Get artist from a given dict.\n\n    Arguments:\n    ---------\n        music: music dict from API\n\n    Returns:\n    -------\n        artist: string representing the artist\n\n    \"\"\"\n    artist = \"\"\n    if music.get(\"artists\") is not None:\n        artists = music.get(\"artists\")\n        if isinstance(artists, list):\n            artist = \", \".join([a.get(\"name\") for a in artists])\n        else:\n            # Yet another 'wrong' entry in the database:\n            # artists in custom_files was sometimes recorded as single value\n            # @TODO also remove once way in the past? (2023-01-31)\n            artist = cast(\"str\", artists)\n    elif music.get(\"artist\") is not None:\n        artist = cast(\"str\", music.get(\"artist\"))\n    elif music.get(\"Artist\") is not None:  # pragma: no cover\n        # Uppercase is a hack needed for Jun 2021 since there is a 'wrong' entry\n        # in the database. Going forward the record will be available as 'artist'\n        # in lowercase.\n        # @TODO remove once is waaaay in the past\n        artist = cast(\"str\", music.get(\"Artist\"))\n    return artist\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_composer","title":"<code>get_composer(music)</code>","text":"<p>Get composer from a given dict.</p> <pre><code>music: music dict from API\n</code></pre> <pre><code>composer: string representing the composer\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_composer(music: dict) -&gt; str:\n    \"\"\"Get composer from a given dict.\n\n    Arguments:\n    ---------\n        music: music dict from API\n\n    Returns:\n    -------\n        composer: string representing the composer\n\n    \"\"\"\n    # composers is usually represented as a list of strings, e.g.:\n    # 'contributors': {'composers': ['Alison Rachel Stewart', ...]}\n    # if composers is not in the expected format, we just return an empty string\n    composer = \"\"\n    contributors = music.get(\"contributors\")\n    if contributors is not None:\n        composers = contributors.get(\"composers\")\n        if composers is not None and isinstance(composers, list):\n            composer = \", \".join(composers)\n    return composer\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_csv","title":"<code>get_csv(data, settings)</code>","text":"<p>Create SUISA compatible csv data.</p> <pre><code>data: To data to create csv from\nsettings: The settings provided to the script\n</code></pre> <pre><code>csv: The converted data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_csv(data: list, settings: Settings) -&gt; str:\n    \"\"\"Create SUISA compatible csv data.\n\n    Arguments:\n    ---------\n        data: To data to create csv from\n        settings: The settings provided to the script\n\n    Returns:\n    -------\n        csv: The converted data\n\n    \"\"\"\n    station_name = settings.station.name\n    header = [\n        \"Sender\",\n        \"Titel des Musikwerks\",\n        \"Name des Komponisten\",\n        \"Interpret(en)\",\n        \"Sendedatum\",\n        \"Sendedauer\",\n        \"Sendezeit\",\n        \"ISRC\",\n        \"Label\",\n        \"Identifikationsnummer\",\n        \"Eigenaufnahmen\",\n        \"EAN / GTIN\",\n        \"Albumtitel / Titel des Tontr\u00e4gers\",\n        \"Aufnahmedatum\",\n        \"Aufnahmeland\",\n        \"Erstver\u00f6ffentlichungsdatum\",\n        \"Katalog-Nummer / CD ID\",\n        \"Werkverzeichnisangaben\",\n        \"Bestellnummer\",\n        \"Ver\u00f6ffentlichungsland\",\n        \"Liveaufnahme\",\n    ]\n    csv = StringIO()\n    csv_writer = writer(csv, dialect=\"excel\")\n    csv_writer.writerow(header)\n\n    for entry in tqdm(data, desc=\"preparing tracks for report\"):\n        metadata = entry.get(\"metadata\")\n        # parse timestamp\n        timestamp = datetime.strptime(metadata.get(\"timestamp_local\"), ACRClient.TS_FMT)  # noqa: DTZ007\n\n        ts_date = timestamp.strftime(\"%Y-%m-%d\")\n        ts_time = timestamp.strftime(\"%H:%M:%S\")\n        hours, remainder = divmod(metadata.get(\"played_duration\"), 60 * 60)\n        minutes, seconds = divmod(remainder, 60)\n        # required format of duration field: hh:mm:ss\n        duration = f\"{hours:02}:{minutes:02}:{seconds:02}\"\n\n        try:\n            music = metadata.get(\"music\")[0]\n        except TypeError:\n            music = metadata.get(\"custom_files\")[0]\n        title = music.get(\"title\")\n\n        artist = get_artist(music)\n        composer = get_composer(music)\n\n        works_composer = \", \".join(\n            [\n                c[\"name\"]\n                for c in [\n                    item\n                    for sublist in [w[\"creators\"] for w in music.get(\"works\", [])]\n                    for item in sublist\n                ]\n                if c.get(\"role\", \"\") in [\"C\", \"Composer\", \"W\", \"Writer\"]\n            ],\n        )\n        if works_composer and (not composer or composer == artist):\n            composer = works_composer\n\n        isrc = get_isrc(music)\n        label = music.get(\"label\")\n\n        # load some \"best-effort\" fields\n        album = music.get(\"album\", \"\")\n        cd_id = \"\"\n        # it's a dict if it's from the ACRCloud bucket, a string if from a custom bucket\n        if isinstance(album, dict):\n            cd_id = album.get(\"cd_id\", \"\")\n            album = album.get(\"name\", \"\")\n        upc = music.get(\"external_ids\", {}).get(\"upc\", \"\")\n        release_date = funge_release_date(music.get(\"release_date\", \"\"))\n\n        local_id: str = \"\"\n        # cridlib only supports timezone-aware datetime values, so we convert one\n        timestamp_utc = pytz.utc.localize(\n            datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n        )\n        # we include the acrid in our CRID so we know about the data's provenience\n        # in case any questions about the data we delivered are asked\n        acrid = music.get(\"acrid\")\n\n        if settings.crid_mode == IdentifierMode.cridlib:\n            local_id = str(\n                cridlib.get(timestamp=timestamp_utc, fragment=f\"acrid={acrid}\")\n            )\n        elif settings.crid_mode == IdentifierMode.local:\n            local_id = f\"{timestamp_utc.isoformat()}#acrid={acrid}\"\n\n        csv_writer.writerow(\n            [\n                station_name,\n                title,\n                composer,\n                artist,\n                ts_date,\n                duration,\n                ts_time,\n                isrc,\n                label,\n                local_id,\n                \"nein\",  # Eigenaufnahmen\n                upc,\n                album,\n                \"\",  # Aufnahmedatum\n                \"\",  # Aufnahmeland\n                release_date,\n                cd_id,\n                \"\",  # Werkverzeichnisangaben\n                \"\",  # Bestellnummer\n                \"\",  # Ver\u00f6ffentlichungsland\n                \"\",  # Liveaufnahme\n            ],\n        )\n    return csv.getvalue()\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_email_attachment","title":"<code>get_email_attachment(filename, filetype, data)</code>","text":"<p>Create attachment based on required filetype and data.</p> <pre><code>filename: The filename of the attachment\nfiletype: The filetype of the attachment\ndata: The attachment data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_email_attachment(filename: str, filetype: str, data: BytesIO | str) -&gt; MIMEBase:\n    \"\"\"Create attachment based on required filetype and data.\n\n    Arguments:\n    ---------\n        filename: The filename of the attachment\n        filetype: The filetype of the attachment\n        data: The attachment data\n\n    \"\"\"\n    maintype = \"application\"\n    subtype = \"vnd.ms-excel\"\n    if filetype == \"csv\":\n        maintype = \"text\"\n        subtype = \"csv\"\n        part = MIMEBase(\"text\", \"csv\")\n\n    payload = (\n        data.getvalue() if isinstance(data, BytesIO) else str(data).encode(\"utf-8\")\n    )\n\n    part = MIMEBase(maintype, subtype)\n    part.set_payload(payload)\n    encode_base64(part)\n    part.add_header(\n        \"Content-Disposition\", f\"attachment; filename={Path(filename).name}\"\n    )\n    return part\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_isrc","title":"<code>get_isrc(music)</code>","text":"<p>Get a valid ISRC from the music record or return an empty string.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_isrc(music: dict) -&gt; str:\n    \"\"\"Get a valid ISRC from the music record or return an empty string.\"\"\"\n    isrc = \"\"\n    if music.get(\"external_ids\", {}).get(\"isrc\"):\n        isrc = music.get(\"external_ids\", {}).get(\"isrc\")\n    elif music.get(\"isrc\"):\n        isrc = cast(\"str\", music.get(\"isrc\"))\n    # was a list with a singular entry for a while back in 2021\n    if isinstance(isrc, list):\n        isrc = isrc[0]\n    # some records contain the \"ISRC\" prefix that is described as legacy\n    # in the ISRC handbook from IFPI.\n    if isrc and isrc[:4] == \"ISRC\":\n        isrc = isrc[4:]\n    # take care of cases where the isrc is space delimited even though the\n    # record is technically wrong but happens often enough to warrant this\n    # hack.\n    if isrc:\n        isrc = isrc.replace(\" \", \"\")\n\n    if not ISRC.validate(isrc):\n        isrc = \"\"\n    return isrc\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_xlsx","title":"<code>get_xlsx(data, settings)</code>","text":"<p>Create SUISA compatible xlsx data.</p> <pre><code>data: The data to create xlsx from\nsettings: The settings provided to the script\n</code></pre> <pre><code>xlsx: The converted data as BytesIO object\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_xlsx(data: list[dict], settings: Settings) -&gt; BytesIO:\n    \"\"\"Create SUISA compatible xlsx data.\n\n    Arguments:\n    ---------\n        data: The data to create xlsx from\n        settings: The settings provided to the script\n\n    Returns:\n    -------\n        xlsx: The converted data as BytesIO object\n\n    \"\"\"\n    csv = get_csv(data, settings=settings)\n    csv_reader = reader(StringIO(csv))\n\n    xlsx = BytesIO()\n    workbook: Workbook = Workbook()\n    workbook.iso_dates = True\n    if not workbook.active:  # pragma: no cover\n        raise RuntimeError\n    worksheet: Worksheet = workbook.active  # type: ignore[assignment]\n\n    for row in csv_reader:\n        worksheet.append(row)\n\n    # the columns that should be styled as required (grey background)\n    required_columns = [\n        \"Sender\",\n        \"Titel des Musikwerks\",\n        \"Name des Komponisten\",\n        \"Interpret(en)\",\n        \"Sendedatum\",\n        \"Sendedauer\",\n        \"Sendezeit\",\n        \"ISRC\",\n        \"Label\",\n        \"Identifikationsnummer\",\n        \"Eigenaufnahmen\",\n    ]\n    subsidiary_columns = [\n        \"EAN/GTIN\",\n        \"Albumtitel / Titel des Tontr\u00e4gers\",\n        \"Aufnahmedatum\",\n        \"Aufnahmeland\",\n        \"Erstver\u00f6ffentlichungsdatum\",\n        \"Katalog-Nummer / CD ID\",\n        \"Werkverzeichnisangaben\",\n        \"Bestellnummer\",\n    ]\n    font = Font(name=\"Calibri\", bold=True, size=12)\n    side = Side(border_style=\"thick\", color=\"000000\")\n    border = Border(top=side, left=side, right=side, bottom=side)\n    required_fill = PatternFill(\"solid\", bgColor=\"bfbfbf\", fgColor=\"bfbfbf\")\n    subsdiary_fill = PatternFill(\"solid\", bgColor=\"ebf1de\", fgColor=\"ebf1de\")\n    for cell in worksheet[1]:  # xlsx is 1-indexed\n        cell.font = font\n        cell.border = border\n        if cell.value in required_columns:\n            cell.fill = required_fill\n        elif cell.value in subsidiary_columns:\n            cell.fill = subsdiary_fill\n\n    # Try to approximate the required width by finding the longest values per column\n    dims: dict[str, int] = {}\n    calc_row: tuple[Cell | MergedCell, ...]\n    for calc_row in worksheet.rows:\n        for cell in calc_row:\n            if isinstance(cell, Cell) and cell.value:\n                dims[cell.column_letter] = max(\n                    (dims.get(cell.column_letter, 0), len(str(cell.value))),\n                )\n    # apply estimated width to each column\n    padding = 3\n    for col, value in dims.items():\n        worksheet.column_dimensions[col].width = value + padding\n\n    reformat_start_date_in_xlsx(worksheet)\n\n    workbook.save(xlsx)\n    return xlsx\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.main","title":"<code>main(settings)</code>","text":"<p>ACRCloud client for SUISA reporting @ RaBe.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def main(settings: Settings) -&gt; None:  # pragma: no cover\n    \"\"\"ACRCloud client for SUISA reporting @ RaBe.\"\"\"\n    validate_arguments(settings)\n\n    start_date, end_date = parse_date(settings)\n    filename = parse_filename(settings, start_date)\n\n    client = ACRClient(bearer_token=str(settings.acr.bearer_token))\n    data = client.get_interval_data(\n        settings.acr.project_id,\n        str(settings.acr.stream_id),\n        start_date,\n        end_date,\n        timezone=settings.l10n.timezone,\n    )\n    data = merge_duplicates(data)\n    if settings.file.format == FileFormat.xlsx:\n        data = get_xlsx(data, settings=settings)\n    elif settings.file.format == FileFormat.csv:\n        data = get_csv(data, settings=settings)\n\n    if settings.output == OutputMode.email:\n        email_subject = Template(settings.email.subject).substitute(\n            {\n                \"station_name\": settings.station.name,\n                \"year\": format_date(\n                    start_date, format=\"yyyy\", locale=settings.l10n.locale\n                ),\n                \"month\": format_date(\n                    start_date, format=\"MM\", locale=settings.l10n.locale\n                ),\n            },\n        )\n        # generate body\n        text = Template(settings.email.text).substitute(\n            {\n                \"station_name\": settings.station.name,\n                \"month\": format_date(\n                    start_date, format=\"MMMM\", locale=settings.l10n.locale\n                ),\n                \"year\": format_date(\n                    start_date, format=\"yyyy\", locale=settings.l10n.locale\n                ),\n                \"previous_year\": format_date(\n                    start_date - timedelta(days=365),\n                    format=\"yyyy\",\n                    locale=settings.l10n.locale,\n                ),\n                \"in_three_months\": format_date(\n                    datetime.now() + relativedelta(months=+3),  # noqa: DTZ005\n                    format=\"long\",\n                    locale=settings.l10n.locale,\n                ),\n                \"responsible_email\": settings.email.responsible_email,\n                \"email_footer\": settings.email.footer,\n            },\n        )\n        msg = create_message(\n            settings.email.sender,\n            settings.email.to,\n            email_subject,\n            text,\n            filename,\n            settings.file.format,\n            data,  # pyright: ignore[reportArgumentType]\n            cc=settings.email.cc,\n            bcc=settings.email.bcc,\n        )\n        send_message(\n            msg,\n            server=settings.email.server,\n            port=settings.email.port,\n            login=settings.email.username,\n            password=settings.email.password,\n        )\n\n    elif settings.output == OutputMode.file and settings.file.format == FileFormat.xlsx:\n        write_xlsx(filename, data)  # pyright: ignore[reportArgumentType]\n    elif settings.output == OutputMode.file and settings.file.format == FileFormat.csv:\n        write_csv(filename, data)  # pyright: ignore[reportArgumentType]\n    elif (\n        settings.output == OutputMode.stdout and settings.file.format == FileFormat.csv\n    ):\n        print(data)  # noqa: T201\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.merge_duplicates","title":"<code>merge_duplicates(data)</code>","text":"<p>Merge consecutive entries into one if they are duplicates.</p> <pre><code>data: The data provided by ACRClient\n</code></pre> <pre><code>data: The processed data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def merge_duplicates(data: list) -&gt; list:\n    \"\"\"Merge consecutive entries into one if they are duplicates.\n\n    Arguments:\n    ---------\n        data: The data provided by ACRClient\n\n    Returns:\n    -------\n        data: The processed data\n\n    \"\"\"\n    prev = data[0]\n    mark = []\n    for entry in data[1:]:\n        if check_duplicate(prev, entry):\n            prev[\"metadata\"][\"played_duration\"] = (\n                prev[\"metadata\"][\"played_duration\"]\n                + entry[\"metadata\"][\"played_duration\"]\n            )\n            # mark entry for removal\n            mark.append(entry)\n        else:\n            prev = entry\n    # remove marked entries\n    for entry in mark:\n        data.remove(entry)\n    return data\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.parse_date","title":"<code>parse_date(settings)</code>","text":"<p>Parse date from args.</p> <pre><code>settings: The settings provided to the script\n</code></pre> <pre><code>start_date: the start date of the requested interval\nend_date: the end date of the requested interval\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def parse_date(settings: Settings) -&gt; tuple[date, date]:\n    \"\"\"Parse date from args.\n\n    Arguments:\n    ---------\n        settings: The settings provided to the script\n\n    Returns:\n    -------\n        start_date: the start date of the requested interval\n        end_date: the end date of the requested interval\n\n    \"\"\"\n    # default values\n    end_date: date = date.today()  # noqa: DTZ011\n    start_date: date = end_date - timedelta(days=30)\n\n    # date parsing logic\n    if settings.date.last_month:\n        today = date.today()  # noqa: DTZ011\n        # get first of this month\n        this_month = today.replace(day=1)\n        # last day of last month = first day of this month - 1 day\n        end_date = this_month - timedelta(days=1)\n        start_date = end_date.replace(day=1)\n    else:\n        if settings.date.end:\n            end_date = datetime.strptime(settings.date.end, \"%Y-%m-%d\").date()  # noqa: DTZ007\n        if settings.date.start:\n            start_date = datetime.strptime(settings.date.start, \"%Y-%m-%d\").date()  # noqa: DTZ007\n    return start_date, end_date\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.parse_filename","title":"<code>parse_filename(settings, start_date)</code>","text":"<p>Parse filename from settings and start_date.</p> <pre><code>settings: the settings provided to the script\nstart_date: start of reporting period\n</code></pre> <pre><code>filename: the filename to use for the csv data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def parse_filename(settings: Settings, start_date: date) -&gt; str:\n    \"\"\"Parse filename from settings and start_date.\n\n    Arguments:\n    ---------\n        settings: the settings provided to the script\n        start_date: start of reporting period\n\n    Returns:\n    -------\n        filename: the filename to use for the csv data\n\n    \"\"\"\n    if settings.file.path:\n        filename = settings.file.path\n    # depending on date args either append the month or the start_date\n    elif settings.date.last_month:\n        date_part = f\"{start_date.strftime('%Y')}_{start_date.strftime('%m')}\"\n        filename = f\"{settings.station.name_short}_{date_part}.{settings.file.format}\"\n    else:\n        filename = (\n            f\"{settings.station.name_short}_\"\n            f\"{start_date.strftime('%Y-%m-%d')}.{settings.file.format}\"\n        )\n    return filename\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.reformat_start_date_in_xlsx","title":"<code>reformat_start_date_in_xlsx(worksheet)</code>","text":"<p>Set date number formatting on relevant columns.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def reformat_start_date_in_xlsx(worksheet: Worksheet) -&gt; None:\n    \"\"\"Set date number formatting on relevant columns.\"\"\"\n    for idx, row in enumerate(worksheet.rows):\n        # skip first row\n        if idx &lt; 1:\n            continue\n\n        # turn the str from the CSV into a real datetime.datetime in Sendedatum column\n        row[4].value = datetime.strptime(  # noqa: DTZ007\n            f\"{row[4].value} {row[6].value}\", \"%Y-%m-%d %H:%M:%S\"\n        ).date()  # pyright: ignore[reportAttributeAccessIssue]\n        # adjust the formatting\n        row[4].number_format = \"dd.mm.yyyy\"\n\n        # same thing for date fields \"Aufnahmedatum\" and \"Erstver\u00f6ffentlichungsdatum\"\n        for col_idx in [13, 15]:\n            row[col_idx].value = (\n                datetime.strptime(  # noqa: DTZ007\n                    str(row[col_idx].value), \"%Y%m%d\"\n                ).date()\n                if row[col_idx].value\n                else None\n            )  # pyright: ignore[reportAttributeAccessIssue]\n            row[col_idx].number_format = \"dd.mm.yyyy\"\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.send_message","title":"<code>send_message(msg, server='127.0.0.1', port=587, login=None, password=None)</code>","text":"<p>Send email.</p> <pre><code>msg: The message to send (an email.message.Message object)\nserver: The SMTP server to use to send the email.\nport: The port of the SMTP server.\nlogin: The username for `sender`@`server`.\npassword: The password for `sender`@`server`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def send_message(\n    msg: MIMEMultipart,\n    server: str = \"127.0.0.1\",\n    port: int = 587,\n    login: str | None = None,\n    password: str | None = None,\n) -&gt; None:\n    \"\"\"Send email.\n\n    Arguments:\n    ---------\n        msg: The message to send (an email.message.Message object)\n        server: The SMTP server to use to send the email.\n        port: The port of the SMTP server.\n        login: The username for `sender`@`server`.\n        password: The password for `sender`@`server`.\n\n    \"\"\"\n    with SMTP(host=server, port=port) as smtp:\n        smtp.starttls()\n        if password:\n            if login:\n                smtp.login(login, password)\n            else:\n                smtp.login(msg[\"From\"], password)\n        smtp.send_message(msg)\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.validate_arguments","title":"<code>validate_arguments(settings)</code>","text":"<p>Validate the arguments provided to the script.</p> <p>After this function we are sure that there are no conflicts in the arguments.</p> <pre><code>settings: the Settings instance to validate\n</code></pre> <pre><code>InvalidValueError: if there are invalid argument combinations\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def validate_arguments(settings: Settings) -&gt; None:\n    \"\"\"Validate the arguments provided to the script.\n\n    After this function we are sure that there are no conflicts in the arguments.\n\n    Arguments:\n    ---------\n        settings: the Settings instance to validate\n\n    Raises:\n    ------\n        InvalidValueError: if there are invalid argument combinations\n\n    \"\"\"\n    msgs = []\n    # xlsx cannot be printed to stdout\n    if (\n        settings.output == OutputMode.stdout\n        and settings.file\n        and settings.file.format == FileFormat.xlsx\n    ):\n        msgs.append(\"xlsx cannot be printed to stdout, please set --file-format to csv\")\n    # last_month is in conflict with start_date and end_date\n    if settings.date.last_month and (settings.date.start or settings.date.end):\n        msgs.append(\"argument --last-month not allowed with --date-start or --date-end\")\n    # exit if there are error messages\n    if msgs:\n        raise InvalidValueError(msgs)\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.write_csv","title":"<code>write_csv(filename, csv)</code>","text":"<p>Write contents of <code>csv</code> to file.</p> <pre><code>filename: The file to write to.\ncsv: The data to write to `filename`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def write_csv(filename: str, csv: BytesIO | str) -&gt; None:  # pragma: no cover\n    \"\"\"Write contents of `csv` to file.\n\n    Arguments:\n    ---------\n        filename: The file to write to.\n        csv: The data to write to `filename`.\n\n    \"\"\"\n    with Path(filename).open(\"w\", encoding=\"utf-8\") as csvfile:\n        csvfile.write(str(csv))\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.write_xlsx","title":"<code>write_xlsx(filename, xlsx)</code>","text":"<p>Write contents of <code>xlsx</code> to file.</p> <pre><code>filename: The file to write to.\nxlsx: The data to write to `filename`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def write_xlsx(filename: str, xlsx: BytesIO) -&gt; None:  # pragma: no cover\n    \"\"\"Write contents of `xlsx` to file.\n\n    Arguments:\n    ---------\n        filename: The file to write to.\n        xlsx: The data to write to `filename`.\n\n    \"\"\"\n    with Path(filename).open(\"wb\") as xlsxfile:\n        xlsxfile.write(xlsx.getvalue())\n</code></pre>"}]}