{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"configuration/","title":"Configuration","text":"<p>SUISA Sendemeldung can be configured via three layers, evaluated in order from lowest to highest priority:</p> <ol> <li>Configuration files (TOML)</li> <li>Environment variables</li> <li>CLI flags</li> </ol> <p>CLI flags override environment variables, which in turn override the configuration file. This means you can keep static settings in a file and supply secrets as environment variables without touching the file.</p>"},{"location":"configuration/#configuration-files","title":"Configuration files","text":"<p>The following files are evaluated in order, last value wins:</p> Path Notes <code>/etc/suisa_sendemeldung.toml</code> System-wide defaults <code>./suisa_sendemeldung.toml</code> Per-directory / per-project overrides <p>A full annotated example is available in <code>etc/suisa_sendemeldung.toml</code>.</p>"},{"location":"configuration/#all-options","title":"All options","text":"<p>Every option below maps to a TOML key under <code>[sendemeldung]</code>, an environment variable prefixed <code>SENDEMELDUNG_</code>, and a CLI flag of the same name.</p>"},{"location":"configuration/#acr-settings","title":"ACR settings","text":"<p>These connect the tool to your ACRCloud project.</p> Option Env var Default Description <code>acr.bearer-token</code> <code>SENDEMELDUNG_ACR_BEARER_TOKEN</code> \u2014 ACRCloud API bearer token (required) <code>acr.stream-id</code> <code>SENDEMELDUNG_ACR_STREAM_ID</code> \u2014 ACRCloud stream ID (required) <code>acr.project-id</code> <code>SENDEMELDUNG_ACR_PROJECT_ID</code> \u2014 ACRCloud project ID (required) <code>acr.url</code> <code>SENDEMELDUNG_ACR_URL</code> <code>https://eu-api-v2.acrcloud.com</code> ACRCloud API base URL"},{"location":"configuration/#date-settings","title":"Date settings","text":"<p>Control the reporting period.</p> Option Env var Default Description <code>date.start</code> <code>SENDEMELDUNG_DATE_START</code> \u2014 Start date (<code>YYYY-MM-DD</code>) <code>date.end</code> <code>SENDEMELDUNG_DATE_END</code> \u2014 End date (<code>YYYY-MM-DD</code>) <code>date.last-month</code> <code>SENDEMELDUNG_DATE_LAST_MONTH</code> <code>true</code> Fetch the whole previous calendar month <p>Date modes</p> <p>Use the CLI flag <code>--last-month</code> (default) to report on the previous calendar month. Pass <code>--by-date</code> together with <code>--date-start</code> / <code>--date-end</code> for a custom range. The two modes are mutually exclusive.</p>"},{"location":"configuration/#output-settings","title":"Output settings","text":"Option Env var Default Description <code>output</code> <code>SENDEMELDUNG_OUTPUT</code> <code>file</code> Output mode: <code>file</code>, <code>email</code>, or <code>stdout</code>"},{"location":"configuration/#file-settings","title":"File settings","text":"<p>Used when <code>output = \"file\"</code> (or <code>\"email\"</code> as attachment).</p> Option Env var Default Description <code>file.path</code> <code>SENDEMELDUNG_FILE_PATH</code> <code>suisa_sendemeldung.csv</code> Output file path <code>file.format</code> <code>SENDEMELDUNG_FILE_FORMAT</code> <code>xlsx</code> Output format: <code>xlsx</code> or <code>csv</code>"},{"location":"configuration/#email-settings","title":"Email settings","text":"<p>Used when <code>output = \"email\"</code>.</p> Option Env var Default Description <code>email.sender</code> <code>SENDEMELDUNG_EMAIL_SENDER</code> \u2014 Sender address <code>email.to</code> <code>SENDEMELDUNG_EMAIL_TO</code> \u2014 Recipient address <code>email.server</code> <code>SENDEMELDUNG_EMAIL_SERVER</code> \u2014 SMTP server hostname <code>email.password</code> <code>SENDEMELDUNG_EMAIL_PASSWORD</code> \u2014 SMTP password <code>email.subject</code> <code>SENDEMELDUNG_EMAIL_SUBJECT</code> <code>SUISA report</code> Email subject <code>email.text</code> <code>SENDEMELDUNG_EMAIL_TEXT</code> (Swiss German template) Email body (<code>$</code>-substitution supported) <code>email.responsible-email</code> <code>SENDEMELDUNG_EMAIL_RESPONSIBLE_EMAIL</code> \u2014 Address for SUISA queries (used in email body) <code>email.footer</code> <code>SENDEMELDUNG_EMAIL_FOOTER</code> (project URL) Footer appended to the email body <p>Email template variables</p> <p>The default email body is a fully SUISA-compliant Swiss German letter that automatically substitutes <code>$station_name</code>, <code>$month</code>, <code>$year</code>, <code>$responsible_email</code>, <code>$in_three_months</code>, and <code>$email_footer</code>.</p>"},{"location":"configuration/#station-settings","title":"Station settings","text":"Option Env var Default Description <code>station.name</code> <code>SENDEMELDUNG_STATION_NAME</code> <code>Radio Bern RaBe</code> Station name used in output and emails <code>station.name-short</code> <code>SENDEMELDUNG_STATION_NAME_SHORT</code> <code>rabe</code> Short name used in filenames"},{"location":"configuration/#localisation-settings","title":"Localisation settings","text":"Option Env var Default Description <code>l10n.timezone</code> <code>SENDEMELDUNG_L10N_TIMEZONE</code> <code>Europe/Zurich</code> Timezone for date output"},{"location":"configuration/#identifier-settings","title":"Identifier settings","text":"<p>Controls how the unique track identifier (<code>CRID</code>) is generated.</p> Option Env var Default Description <code>crid-mode</code> <code>SENDEMELDUNG_CRID_MODE</code> <code>local</code> <code>cridlib</code> (standard CRID) or <code>local</code> (UUID-based)"},{"location":"configuration/#minimal-example","title":"Minimal example","text":"<pre><code>[sendemeldung]\noutput = \"file\"\n\nacr.bearer-token = \"ey...\"\nacr.stream-id    = \"a-bcdefgh\"\nacr.project-id   = \"1234\"\n</code></pre>"},{"location":"configuration/#full-example-with-email-delivery","title":"Full example with email delivery","text":"<pre><code>[sendemeldung]\noutput = \"email\"\n\nacr.bearer-token = \"ey...\"\nacr.stream-id    = \"a-bcdefgh\"\nacr.project-id   = \"1234\"\n\ndate.last-month = true\n\nemail.sender            = \"sendemeldung@example.org\"\nemail.to                = \"sendemeldung@suisa.ch\"\nemail.server            = \"smtp.example.org\"\nemail.password          = \"s3cr3t\"\nemail.responsible-email = \"responsible@example.org\"\n\nstation.name   = \"Radio Example\"\nemail.footer   = \"Radio Example | Musterstrasse 1 | 3000 Bern\"\n\nl10n.timezone  = \"Europe/Zurich\"\n</code></pre>"},{"location":"configuration/#environment-variables-example","title":"Environment variables example","text":"<pre><code>podman run --rm -ti \\\n  -e SENDEMELDUNG_ACR_BEARER_TOKEN=ey... \\\n  -e SENDEMELDUNG_ACR_STREAM_ID=a-bcdefgh \\\n  -e SENDEMELDUNG_ACR_PROJECT_ID=1234 \\\n  -e SENDEMELDUNG_OUTPUT=stdout \\\n  ghcr.io/radiorabe/suisasendemeldung:latest\n</code></pre>"},{"location":"deployment/","title":"Deployment","text":"<p>This guide shows how to run SUISA Sendemeldung in production so that the monthly report is generated and sent automatically on a schedule.</p>"},{"location":"deployment/#supported-deployment-models","title":"Supported deployment models","text":"Model Recommended for systemd timer Self-hosted Linux servers (bare metal or VM) Container (one-shot) Any host with rootless Podman Cron job Minimal setups without systemd"},{"location":"deployment/#systemd-timer","title":"systemd timer","text":"<p>The <code>etc/systemd/</code> directory in this repository ships a ready-to-use template unit pair.</p>"},{"location":"deployment/#quick-setup","title":"Quick setup","text":"<pre><code># 1. Copy configuration\nsudo mkdir -p /etc/suisa_sendemeldung\nsudo cp etc/suisa_sendemeldung.toml /etc/suisa_sendemeldung/production.toml\n# edit the file and fill in your credentials\nsudo $EDITOR /etc/suisa_sendemeldung/production.toml\n\n# 2. Install units\nsudo cp etc/systemd/suisa_sendemeldung@.service /etc/systemd/system/\nsudo cp etc/systemd/suisa_sendemeldung@.timer   /etc/systemd/system/\n\n# 3. Enable and start\nsudo systemctl daemon-reload\nsudo systemctl enable --now 'suisa_sendemeldung@production.timer'\n\n# 4. Verify\nsystemctl list-timers suisa_sendemeldung@production.timer\n</code></pre>"},{"location":"deployment/#how-the-units-work","title":"How the units work","text":"<p><code>suisa_sendemeldung@.service</code> is a template service that:</p> <ul> <li>Pulls the latest container image before each run.</li> <li>Mounts <code>/etc/suisa_sendemeldung/%i.toml</code> as <code>/etc/suisa_sendemeldung.toml</code>   inside the container (where <code>%i</code> is the instance name \u2014 <code>production</code> in the   example above).</li> <li>Runs the container as a one-shot job and exits when done.</li> </ul> <p><code>suisa_sendemeldung@.timer</code> triggers the service on the 14th of each month at 09:00. RaBe runs the script on the 1st and 14th; adjust the <code>OnCalendar</code> value to suit your schedule.</p> <p>Multiple stations</p> <p>Because the units are template units you can run several instances in parallel, one per station configuration file:</p> <pre><code>systemctl enable --now suisa_sendemeldung@station-a.timer\nsystemctl enable --now suisa_sendemeldung@station-b.timer\n</code></pre>"},{"location":"deployment/#customising-the-schedule","title":"Customising the schedule","text":"<p>Edit the timer's <code>OnCalendar</code> value to change when the report runs:</p> <pre><code>[Timer]\n# Run on the 1st and 14th of every month at 09:00\nOnCalendar=\nOnCalendar=*-*-1,14 09:00:00\nPersistent=true\n</code></pre> <p>After editing, reload the daemon and restart the timer:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl restart suisa_sendemeldung@production.timer\n</code></pre>"},{"location":"deployment/#container-one-shot","title":"Container (one-shot)","text":"<p>Run the container once for a specific month using rootless Podman:</p> <pre><code>podman run --rm \\\n  -v /etc/suisa_sendemeldung/production.toml:/etc/suisa_sendemeldung.toml:ro \\\n  ghcr.io/radiorabe/suisasendemeldung:latest \\\n  suisa_sendemeldung --last-month\n</code></pre> <p>Docker</p> <p>Docker works as a drop-in replacement \u2014 substitute <code>docker</code> for <code>podman</code> in any of the commands above. Rootless Podman is strongly recommended.</p> <p>All configuration can also be passed as environment variables without a mounted config file:</p> <pre><code>podman run --rm \\\n  -e SENDEMELDUNG_ACR_BEARER_TOKEN=ey... \\\n  -e SENDEMELDUNG_ACR_STREAM_ID=a-bcdefgh \\\n  -e SENDEMELDUNG_ACR_PROJECT_ID=1234 \\\n  -e SENDEMELDUNG_OUTPUT=email \\\n  -e SENDEMELDUNG_EMAIL_SERVER=smtp.example.org \\\n  -e SENDEMELDUNG_EMAIL_SENDER=report@example.org \\\n  -e SENDEMELDUNG_EMAIL_TO=sendemeldung@suisa.ch \\\n  -e SENDEMELDUNG_EMAIL_PASSWORD=s3cr3t \\\n  -e SENDEMELDUNG_DATE_LAST_MONTH=true \\\n  ghcr.io/radiorabe/suisasendemeldung:latest\n</code></pre>"},{"location":"deployment/#cron-job","title":"Cron job","text":"<p>If systemd is not available, use cron:</p> <pre><code># Run on the 14th of every month at 09:00\n0 9 14 * * podman run --rm \\\n  -v /etc/suisa_sendemeldung/production.toml:/etc/suisa_sendemeldung.toml:ro \\\n  ghcr.io/radiorabe/suisasendemeldung:latest \\\n  suisa_sendemeldung --last-month\n</code></pre>"},{"location":"deployment/#monitoring","title":"Monitoring","text":"<p>The systemd service file contains a commented-out <code>ExecStartPost</code> line that sends a Zabbix heartbeat after a successful run. Uncomment and adapt it to your monitoring stack:</p> <pre><code>ExecStartPost=-/bin/sh -c 'zabbix_sender \\\n  -c /etc/zabbix/zabbix_agent2.conf \\\n  -s sendemeldung.example.org \\\n  -k rabe.suisa_sendemeldung.run.success \\\n  -o \"$$(date +%%s)\"'\n</code></pre> <p>Double <code>%</code> in systemd units</p> <p>systemd unit files use <code>%%</code> to produce a literal <code>%</code>. If you adapt this command for a plain shell script, replace <code>%%s</code> with <code>%s</code>.</p>"},{"location":"development/","title":"Development","text":"<p>Thank you for contributing to SUISA Sendemeldung! This page covers everything you need to get a local development environment running and to make changes with confidence.</p>"},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or later</li> <li>Poetry for dependency management</li> </ul>"},{"location":"development/#set-up-the-development-environment","title":"Set up the development environment","text":"<pre><code># Clone the repository\ngit clone https://github.com/radiorabe/suisa_sendemeldung.git\ncd suisa_sendemeldung\n\n# Install all dependencies (including dev extras)\npoetry install\n\n# Verify everything works\npoetry run pytest\n</code></pre>"},{"location":"development/#running-the-tests","title":"Running the tests","text":"<p>The test suite uses pytest with several plugins:</p> Plugin Purpose <code>pytest-cov</code> Coverage reporting (100 % required) <code>pytest-mypy</code> Static type checking <code>pytest-ruff</code> Lint checks via Ruff <code>syrupy</code> Snapshot tests for CLI help output <code>freezegun</code> Deterministic date/time in tests <code>requests-mock</code> HTTP request mocking <pre><code># Run all tests\npoetry run pytest\n\n# Run with verbose output\npoetry run pytest -v\n\n# Update snapshots after intentional output changes\npoetry run pytest --snapshot-update\n</code></pre> <p>100 % coverage required</p> <p>The CI pipeline enforces <code>--cov-fail-under=100</code>. Every new code path must have a corresponding test.</p>"},{"location":"development/#linting-formatting","title":"Linting &amp; formatting","text":"<pre><code># Lint and auto-fix with Ruff\npoetry run ruff check --fix .\npoetry run ruff format .\n\n# Type-check with mypy\npoetry run mypy suisa_sendemeldung/\n</code></pre> <p>Both linters also run automatically as part of <code>pytest</code>.</p>"},{"location":"development/#building-the-documentation","title":"Building the documentation","text":"<pre><code># Serve docs locally with live reload\npoetry run mkdocs serve\n\n# Build a static copy\npoetry run mkdocs build\n</code></pre> <p>Open http://127.0.0.1:8000 in your browser while <code>mkdocs serve</code> is running.</p>"},{"location":"development/#project-structure","title":"Project structure","text":"<pre><code>suisa_sendemeldung/\n\u251c\u2500\u2500 acrclient.py          # ACRCloud API wrapper (interval fetch + TZ localisation)\n\u251c\u2500\u2500 settings.py           # typed-settings definitions (all config knobs)\n\u2514\u2500\u2500 suisa_sendemeldung.py # Main application logic and CLI entry point\n\ntests/\n\u251c\u2500\u2500 conftest.py           # Shared fixtures\n\u251c\u2500\u2500 __snapshots__/        # Syrupy snapshot files\n\u2514\u2500\u2500 test_*.py             # Test modules\n\ndocs/\n\u251c\u2500\u2500 overrides/            # MkDocs Material theme overrides (home template)\n\u251c\u2500\u2500 css/style.css         # Custom styles\n\u251c\u2500\u2500 gen_ref_pages.py      # Auto-generates API reference pages\n\u2514\u2500\u2500 *.md                  # Hand-written documentation pages\n</code></pre>"},{"location":"development/#commit-messages","title":"Commit messages","text":"<p>This project follows the Conventional Commits standard. Commit messages drive automated version bumps and changelog generation via go-semantic-release.</p> Prefix Effect <code>fix:</code> Patch version bump <code>feat:</code> Minor version bump <code>BREAKING CHANGE:</code> footer Major version bump Anything else No release"},{"location":"development/#release-process","title":"Release process","text":"<p>Merging to <code>main</code> with a qualifying commit message automatically:</p> <ol> <li>Creates a GitHub Release via the semantic-release workflow.</li> <li>Publishes the package to PyPI.</li> <li>Builds and pushes the container image to    GitHub Packages.</li> </ol> <p>Releases are intentionally made only in the second half of each month so they are available before the 1st-of-month reporting run.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>ACRCloud client that fetches data on your playout history and formats it into a CSV/XLSX file containing the data (like Track, Title, and ISRC) requested by SUISA. Also takes care of sending the report to SUISA via email for hands-off operations.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>We provide SUISA Sendemeldung as a container image or as a Python package.</p>"},{"location":"getting-started/#container-recommended","title":"Container (recommended)","text":"<p>The easiest way to run SUISA Sendemeldung is with the official container image via rootless Podman:</p> <pre><code>podman run --rm -ti \\\n  ghcr.io/radiorabe/suisasendemeldung:latest \\\n  suisa_sendemeldung --help\n</code></pre> <p>Docker</p> <p>Docker works as a drop-in replacement \u2014 substitute <code>docker</code> for <code>podman</code> in any of the commands above. Rootless Podman is strongly recommended.</p>"},{"location":"getting-started/#python-package","title":"Python package","text":"<p>If you prefer a plain Python install, use <code>pip</code> in a dedicated virtual environment:</p> <pre><code>python -m venv .venv\n. .venv/bin/activate\n\npip install suisa_sendemeldung\nsuisa_sendemeldung --help\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick start","text":"<ol> <li> <p>Obtain your ACRCloud credentials \u2014 bearer token, stream ID, and    project ID from the ACRCloud console.</p> </li> <li> <p>Create a minimal configuration file at <code>suisa_sendemeldung.toml</code>:</p> <pre><code>[sendemeldung]\noutput = \"stdout\"\n\nacr.bearer-token = \"ey...\"\nacr.stream-id    = \"a-bcdefgh\"\nacr.project-id   = \"1234\"\n</code></pre> </li> <li> <p>Run the script for the previous month:</p> <pre><code>suisa_sendemeldung --last-month\n</code></pre> <p>The report is printed to standard output. Change <code>output</code> to <code>\"file\"</code> or <code>\"email\"</code> when you're ready for production.</p> </li> </ol> <p>Date selection</p> <p>Use <code>--last-month</code> for the most common case. For custom ranges pass <code>--by-date</code> with explicit <code>--date-start YYYY-MM-DD</code> and <code>--date-end YYYY-MM-DD</code>.</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Read the Configuration reference for all available   options.</li> <li>Set up automated deployment with systemd timers or a   container orchestrator.</li> <li>Check the Python API Reference if you want to use   the library programmatically.</li> </ul>"},{"location":"upgrading/","title":"Upgrading","text":""},{"location":"upgrading/#upgrade-from-0x-to-10","title":"Upgrade from 0.x to 1.0","text":"<p>Version 1.0 is a significant cleanup release. Review the breaking changes below before upgrading.</p>"},{"location":"upgrading/#configuration-file","title":"Configuration file","text":"0.x 1.0 File name <code>suisa_sendemeldung.conf</code> <code>suisa_sendemeldung.toml</code> Format INI-style (<code>[section]</code> / <code>key = value</code>) TOML <p>Migrate your existing configuration by renaming the file and converting the syntax. Example:</p> 0.x (INI)1.0 (TOML) <pre><code>[settings]\nbearer_token = ey...\nstream_id    = a-bcdefgh\n</code></pre> <pre><code>[sendemeldung]\nacr.bearer-token = \"ey...\"\nacr.stream-id    = \"a-bcdefgh\"\n</code></pre>"},{"location":"upgrading/#cli-flags","title":"CLI flags","text":"<p>All command-line flags have been renamed to match the new TOML key hierarchy. Run <code>suisa_sendemeldung --help</code> to see the current list of flags.</p>"},{"location":"upgrading/#removed-features","title":"Removed features","text":"<p>The \"last 30 days from today\" mode has been dropped. Use Use <code>--last-month</code> (or <code>date.last-month = true</code> in the config file) to report on the previous calendar month, or use <code>--by-date</code> together with explicit <code>--date-start</code> / <code>--date-end</code> values for a custom range.</p>"},{"location":"upgrading/#python-version","title":"Python version","text":"<p>Python 3.12 or later is now required.</p>"},{"location":"upgrading/#support-matrix","title":"Support matrix","text":"Version Supported GST Python Notes 0.x \u2705 GST 2020 \u2014 Internal use at RaBe; maintained on a best-efforts basis for historical reports 1.x \u2705 GST 2026 \u2265 3.12 First public release; actively maintained <p>Old versions are supported on a case-by-case basis when regenerating historical reports.</p>"},{"location":"reference/acrclient/","title":"Acrclient","text":"<p>module containing the ACRCloud client.</p>"},{"location":"reference/acrclient/#acrclient.ACRClient","title":"<code>ACRClient</code>","text":"<p>               Bases: <code>Client</code></p> <p>ACRCloud client wrapper to fetch metadata.</p> <pre><code>bearer_token: The bearer token for ACRCloud.\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>class ACRClient(Client):\n    \"\"\"ACRCloud client wrapper to fetch metadata.\n\n    Arguments:\n    ---------\n        bearer_token: The bearer token for ACRCloud.\n\n    \"\"\"\n\n    # format of timestamp in api answer\n    TS_FMT = \"%Y-%m-%d %H:%M:%S\"\n    # timezone of ACRCloud\n    ACR_TIMEZONE = \"UTC\"\n\n    def __init__(\n        self: Self, bearer_token: str, base_url: str = \"https://eu-api-v2.acrcloud.com\"\n    ) -&gt; None:\n        \"\"\"Init subclass with default_date.\"\"\"\n        super().__init__(bearer_token=bearer_token, base_url=base_url)\n        self.default_date: date = date.today() - timedelta(days=1)  # noqa: DTZ011\n\n    def get_data(\n        self: Self,\n        project_id: int,\n        stream_id: str,\n        requested_date: date | None = None,\n        timezone: str = ACR_TIMEZONE,\n    ) -&gt; Any:  # noqa: ANN401\n        \"\"\"Fetch metadata from ACRCloud for `stream_id`.\n\n        Arguments:\n        ---------\n            project_id: The Project ID of the stream.\n            stream_id: The ID of the stream.\n            requested_date: The date of the entries you want (default: yesterday).\n            timezone: The timezone to use for localization.\n\n        Returns:\n        -------\n            json: The ACR data from date\n\n        \"\"\"\n        if requested_date is None:\n            requested_date = self.default_date\n        data = self.get_bm_cs_projects_results(\n            project_id=project_id,\n            stream_id=stream_id,\n            params=GetBmCsProjectsResultsParams(\n                type=\"day\",\n                date=requested_date.strftime(\"%Y%m%d\"),\n            ),\n        )\n        for entry in data:\n            metadata = entry.get(\"metadata\")\n            ts_utc = pytz.utc.localize(\n                datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n            )\n            ts_local = ts_utc.astimezone(pytz.timezone(timezone))\n            metadata.update({\"timestamp_local\": ts_local.strftime(ACRClient.TS_FMT)})\n\n        return data\n\n    def get_interval_data(  # noqa: ANN201\n        self: Self,\n        project_id: int,\n        stream_id: str,\n        start: date,\n        end: date,\n        timezone: str = ACR_TIMEZONE,\n    ):\n        \"\"\"Get data specified by interval from start to end.\n\n        Arguments:\n        ---------\n            project_id: The ID of the project.\n            stream_id: The ID of the stream.\n            start: The start date of the interval.\n            end: The end date of the interval.\n            timezone (optional): will be passed to `get_data()`.\n\n        Returns:\n        -------\n            json: The ACR data from start to end.\n\n        \"\"\"\n        trim = False\n        # if we have to localize the timestamps we may need more data\n        if timezone != ACRClient.ACR_TIMEZONE:\n            # compute utc offset\n            offset = pytz.timezone(timezone).utcoffset(datetime.now())  # noqa: DTZ005\n            # decrease start by 1 day if we're ahead of utc\n            if offset &gt; timedelta(seconds=1):\n                computed_start = start - timedelta(days=1)\n                computed_end = end\n                trim = True\n            # increase end by 1 day if we're behind of utc\n            elif offset &lt; timedelta(seconds=1):\n                computed_start = start\n                computed_end = end + timedelta(days=1)\n                trim = True\n        else:\n            computed_start = start\n            computed_end = end\n\n        dates = []\n        ptr = computed_start\n        while ptr &lt;= computed_end:\n            dates.append(ptr)\n            ptr += timedelta(days=1)\n        data = []\n        # make the prefix longer by this amount so tqdm lines up with\n        # the one in the main code\n        ljust_amount: int = 27\n        for ptr in tqdm(dates, desc=\"load ACRCloud data\".ljust(ljust_amount)):\n            data += self.get_data(\n                project_id,\n                stream_id,\n                requested_date=ptr,\n                timezone=timezone,\n            )\n\n        # if timestamps are localized we will have to removed the unneeded entries.\n        if trim:\n            for entry in reversed(data):\n                metadata = entry.get(\"metadata\")\n                timestamp = metadata.get(\"timestamp_local\")\n                timestamp_date = datetime.strptime(  # noqa: DTZ007\n                    timestamp, ACRClient.TS_FMT\n                ).date()\n                if timestamp_date &lt; start or timestamp_date &gt; end:\n                    data.remove(entry)\n\n        return data\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.__init__","title":"<code>__init__(bearer_token, base_url='https://eu-api-v2.acrcloud.com')</code>","text":"<p>Init subclass with default_date.</p> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def __init__(\n    self: Self, bearer_token: str, base_url: str = \"https://eu-api-v2.acrcloud.com\"\n) -&gt; None:\n    \"\"\"Init subclass with default_date.\"\"\"\n    super().__init__(bearer_token=bearer_token, base_url=base_url)\n    self.default_date: date = date.today() - timedelta(days=1)  # noqa: DTZ011\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.get_data","title":"<code>get_data(project_id, stream_id, requested_date=None, timezone=ACR_TIMEZONE)</code>","text":"<p>Fetch metadata from ACRCloud for <code>stream_id</code>.</p> <pre><code>project_id: The Project ID of the stream.\nstream_id: The ID of the stream.\nrequested_date: The date of the entries you want (default: yesterday).\ntimezone: The timezone to use for localization.\n</code></pre> <pre><code>json: The ACR data from date\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def get_data(\n    self: Self,\n    project_id: int,\n    stream_id: str,\n    requested_date: date | None = None,\n    timezone: str = ACR_TIMEZONE,\n) -&gt; Any:  # noqa: ANN401\n    \"\"\"Fetch metadata from ACRCloud for `stream_id`.\n\n    Arguments:\n    ---------\n        project_id: The Project ID of the stream.\n        stream_id: The ID of the stream.\n        requested_date: The date of the entries you want (default: yesterday).\n        timezone: The timezone to use for localization.\n\n    Returns:\n    -------\n        json: The ACR data from date\n\n    \"\"\"\n    if requested_date is None:\n        requested_date = self.default_date\n    data = self.get_bm_cs_projects_results(\n        project_id=project_id,\n        stream_id=stream_id,\n        params=GetBmCsProjectsResultsParams(\n            type=\"day\",\n            date=requested_date.strftime(\"%Y%m%d\"),\n        ),\n    )\n    for entry in data:\n        metadata = entry.get(\"metadata\")\n        ts_utc = pytz.utc.localize(\n            datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n        )\n        ts_local = ts_utc.astimezone(pytz.timezone(timezone))\n        metadata.update({\"timestamp_local\": ts_local.strftime(ACRClient.TS_FMT)})\n\n    return data\n</code></pre>"},{"location":"reference/acrclient/#acrclient.ACRClient.get_interval_data","title":"<code>get_interval_data(project_id, stream_id, start, end, timezone=ACR_TIMEZONE)</code>","text":"<p>Get data specified by interval from start to end.</p> <pre><code>project_id: The ID of the project.\nstream_id: The ID of the stream.\nstart: The start date of the interval.\nend: The end date of the interval.\ntimezone (optional): will be passed to `get_data()`.\n</code></pre> <pre><code>json: The ACR data from start to end.\n</code></pre> Source code in <code>suisa_sendemeldung/acrclient.py</code> <pre><code>def get_interval_data(  # noqa: ANN201\n    self: Self,\n    project_id: int,\n    stream_id: str,\n    start: date,\n    end: date,\n    timezone: str = ACR_TIMEZONE,\n):\n    \"\"\"Get data specified by interval from start to end.\n\n    Arguments:\n    ---------\n        project_id: The ID of the project.\n        stream_id: The ID of the stream.\n        start: The start date of the interval.\n        end: The end date of the interval.\n        timezone (optional): will be passed to `get_data()`.\n\n    Returns:\n    -------\n        json: The ACR data from start to end.\n\n    \"\"\"\n    trim = False\n    # if we have to localize the timestamps we may need more data\n    if timezone != ACRClient.ACR_TIMEZONE:\n        # compute utc offset\n        offset = pytz.timezone(timezone).utcoffset(datetime.now())  # noqa: DTZ005\n        # decrease start by 1 day if we're ahead of utc\n        if offset &gt; timedelta(seconds=1):\n            computed_start = start - timedelta(days=1)\n            computed_end = end\n            trim = True\n        # increase end by 1 day if we're behind of utc\n        elif offset &lt; timedelta(seconds=1):\n            computed_start = start\n            computed_end = end + timedelta(days=1)\n            trim = True\n    else:\n        computed_start = start\n        computed_end = end\n\n    dates = []\n    ptr = computed_start\n    while ptr &lt;= computed_end:\n        dates.append(ptr)\n        ptr += timedelta(days=1)\n    data = []\n    # make the prefix longer by this amount so tqdm lines up with\n    # the one in the main code\n    ljust_amount: int = 27\n    for ptr in tqdm(dates, desc=\"load ACRCloud data\".ljust(ljust_amount)):\n        data += self.get_data(\n            project_id,\n            stream_id,\n            requested_date=ptr,\n            timezone=timezone,\n        )\n\n    # if timestamps are localized we will have to removed the unneeded entries.\n    if trim:\n        for entry in reversed(data):\n            metadata = entry.get(\"metadata\")\n            timestamp = metadata.get(\"timestamp_local\")\n            timestamp_date = datetime.strptime(  # noqa: DTZ007\n                timestamp, ACRClient.TS_FMT\n            ).date()\n            if timestamp_date &lt; start or timestamp_date &gt; end:\n                data.remove(entry)\n\n    return data\n</code></pre>"},{"location":"reference/settings/","title":"Settings","text":"<p>Settings for SUISA Sendemeldung.</p>"},{"location":"reference/settings/#settings.ACR","title":"<code>ACR</code>","text":"<p>ACRCloud configuration</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass ACR:\n    \"\"\"ACRCloud configuration\"\"\"  # noqa: D400, D415\n\n    bearer_token: str = ts.secret(\n        help=\"Bearer token for ACRCloud API access\",\n        validator=validators.min_len(32),\n    )\n    project_id: int = ts.option(\n        help=\"Id of the project in ACRCloud\",\n        validator=validators.ge(0),\n    )\n    stream_id: str = ts.option(\n        help=\"Id of the stream in ACRCloud\",\n        validator=validators.min_len(9),\n    )\n</code></pre>"},{"location":"reference/settings/#settings.EmailSettings","title":"<code>EmailSettings</code>","text":"<p>Email configuration</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass EmailSettings:\n    \"\"\"Email configuration\"\"\"  # noqa: D400, D415\n\n    sender: str = ts.option(help=\"the sender of the email\", default=\"\")\n    to: str = ts.option(help=\"the recipients of the email\", default=\"\")\n    server: str = ts.option(help=\"the smtp server to send the mail with\", default=\"\")\n    port: int = ts.option(help=\"the port of the smtp server\", default=587)\n    username: str = ts.option(\n        help=\"the username to logon to the smtp server (default: email_from)\",\n        default=\"\",\n    )\n    password: str = ts.secret(help=\"the password for the smtp server\", default=\"\")\n    responsible_email: str = ts.option(\n        help=\"Used to hint whom to contact in the emails text.\", default=\"\"\n    )\n    cc: str = ts.option(help=\"the cc recipients of the email\", default=\"\")\n    bcc: str = ts.option(help=\"the bcc recipients of the email\", default=\"\")\n    subject: str = ts.option(\n        help=\"\"\"\n        Template for subject of the email.\n\n        Placeholders are $station_name, $year and $month.\n        \"\"\",\n        default=\"SUISA Sendemeldung von $station_name f\u00fcr $year-$month\",\n        click={\"show_default\": False},\n    )\n    text: str = ts.option(\n        help=\"\"\"\n        Template for email text.\n\n        Placeholders are $station_name, $month, $year, $previous_year,\n        $responsible_email, and $email_footer.\n        \"\"\",\n        default=_EMAIL_TEMPLATE,\n        click={\"show_default\": False},\n    )\n    footer: str = ts.option(\n        help=\"Footer for the Email\",\n        default=\"Email generated by &lt;https://github.com/radiorabe/suisa_sendemeldung&gt;\",\n        click={\"show_default\": False},\n    )\n</code></pre>"},{"location":"reference/settings/#settings.FileFormat","title":"<code>FileFormat</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>File formats for the report.</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>class FileFormat(StrEnum):\n    \"\"\"File formats for the report.\"\"\"\n\n    xlsx = \"xlsx\"\n    csv = \"csv\"\n</code></pre>"},{"location":"reference/settings/#settings.FileSettings","title":"<code>FileSettings</code>","text":"<p>File configuration</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass FileSettings:\n    \"\"\"File configuration\"\"\"  # noqa: D400, D415\n\n    format: FileFormat = ts.option(default=FileFormat.xlsx)\n    path: str = ts.option(default=\"\")\n</code></pre>"},{"location":"reference/settings/#settings.IdentifierMode","title":"<code>IdentifierMode</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Modes for generating the identifier in the report.</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>class IdentifierMode(StrEnum):\n    \"\"\"Modes for generating the identifier in the report.\"\"\"\n\n    local = \"local\"\n    cridlib = \"cridlib\"\n</code></pre>"},{"location":"reference/settings/#settings.LocalizationSettings","title":"<code>LocalizationSettings</code>","text":"<p>Localization configuration</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass LocalizationSettings:\n    \"\"\"Localization configuration\"\"\"  # noqa: D400, D415\n\n    timezone: str = \"Europe/Zurich\"\n    locale: str = \"de_CH\"\n</code></pre>"},{"location":"reference/settings/#settings.OutputMode","title":"<code>OutputMode</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Output modes for the report.</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>class OutputMode(StrEnum):\n    \"\"\"Output modes for the report.\"\"\"\n\n    file = \"file\"\n    email = \"email\"\n    stdout = \"stdout\"\n</code></pre>"},{"location":"reference/settings/#settings.RangeSettings","title":"<code>RangeSettings</code>","text":"<p>Configure the range of the report</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass RangeSettings:\n    \"\"\"Configure the range of the report\"\"\"  # noqa: D400, D415\n\n    last_month: bool = ts.option(\n        help=\"\"\"\n        The default is to generate ia report for the full last month,\n        use --by-date with --date-start and --date-end for a range\n        \"\"\",\n        default=True,\n        click={\"param_decls\": (\"--last-month/--by-date\",)},\n    )\n    start: str = ts.option(\n        help=\"The start date of the interval in format YYYY-MM-DD [env var: SENDEMELDUNG_DATE_START; default: now - 30d]\",  # noqa: E501\n        default=\"\",\n        click={\"show_default\": False, \"show_envvar\": False},\n    )\n    end: str = ts.option(\n        help=\"The end date of the interval in format YYYY-MM-DD [env var: SENDEMELDUNG_DATE_END; default: now]\",  # noqa: E501\n        default=\"\",\n        click={\"show_default\": False, \"show_envvar\": False},\n    )\n</code></pre>"},{"location":"reference/settings/#settings.Settings","title":"<code>Settings</code>","text":"<p>Settings</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass Settings:\n    \"\"\"Settings\"\"\"  # noqa: D400, D415\n\n    output: OutputMode = ts.option(\n        help=\"How to output the report\", default=OutputMode.file\n    )\n    crid_mode: IdentifierMode = ts.option(\n        help=\"How to generate the identifier in the report\",\n        default=IdentifierMode.local,\n    )\n\n    acr: ACR = ts.option(default=None)\n    date: RangeSettings = ts.option(default=RangeSettings())\n    station: StationSettings = ts.option(default=StationSettings())\n    l10n: LocalizationSettings = ts.option(default=LocalizationSettings())\n    file: FileSettings = ts.option(default=FileSettings())\n    email: EmailSettings = ts.option(default=EmailSettings())\n</code></pre>"},{"location":"reference/settings/#settings.StationSettings","title":"<code>StationSettings</code>","text":"<p>Basic station information</p> Source code in <code>suisa_sendemeldung/settings.py</code> <pre><code>@ts.settings\nclass StationSettings:\n    \"\"\"Basic station information\"\"\"  # noqa: D400, D415\n\n    name: str = ts.option(\n        help=\"Station name, used in output and emails\", default=\"Radio Bern RaBe\"\n    )\n    name_short: str = ts.option(\n        help=\"Shortname for station as used in filenames (locally and in attachment)\",\n        default=\"rabe\",\n    )\n</code></pre>"},{"location":"reference/suisa_sendemeldung/","title":"Suisa sendemeldung","text":"<p>SUISA Sendemeldung bugs SUISA with email once per month.</p> <p>Fetches data on our playout history and formats them in a CSV file format containing the data (like Track, Title and ISRC) requested by SUISA. Also takes care of sending the report to SUISA via email for hands-off operations.</p>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.check_duplicate","title":"<code>check_duplicate(entry_a, entry_b)</code>","text":"<p>Check if two entries are duplicates by checking their acrid in all music items.</p> <pre><code>entry_a: first entry\nentry_b: second entry\n</code></pre> <pre><code>True if the entries are duplicates, False otherwise\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def check_duplicate(entry_a: dict, entry_b: dict) -&gt; bool:\n    \"\"\"Check if two entries are duplicates by checking their acrid in all music items.\n\n    Arguments:\n    ---------\n        entry_a: first entry\n        entry_b: second entry\n\n    Returns:\n    -------\n        True if the entries are duplicates, False otherwise\n\n    \"\"\"\n    try:\n        entry_a = entry_a[\"metadata\"][\"music\"]\n    except KeyError:\n        entry_a = entry_a[\"metadata\"][\"custom_files\"]\n    try:\n        entry_b = entry_b[\"metadata\"][\"music\"]\n    except KeyError:\n        entry_b = entry_b[\"metadata\"][\"custom_files\"]\n    for music_a in entry_a:\n        for music_b in entry_b:\n            if music_a[\"acrid\"] == music_b[\"acrid\"]:\n                return True\n    return False\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.cli","title":"<code>cli(settings)</code>","text":"<p>SUISA Sendemeldung.</p> <p>Create and send playout reports to SUISA.</p> <p>The reports are based on data from ACRCloud.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>@click.command()\n@typed_settings.click_options(\n    Settings,\n    loaders=typed_settings.default_loaders(\n        \"sendemeldung\",\n        [\n            \"/etc/suisa_sendemeldung.toml\",\n            \"suisa_sendemeldung.toml\",\n        ],\n    ),\n    decorator_factory=OptionGroupFactory(),\n    show_envvars_in_help=True,\n)\ndef cli(settings: Settings) -&gt; None:  # pragma: no cover\n    \"\"\"SUISA Sendemeldung.\n\n    Create and send playout reports to SUISA.\n\n    The reports are based on data from ACRCloud.\n    \"\"\"\n    main(settings)\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.create_message","title":"<code>create_message(sender, recipient, subject, text, filename, filetype, data, cc=None, bcc=None)</code>","text":"<p>Create email message.</p> <pre><code>sender: The sender of the email. Login will be made with this user.\nrecipient: The recipient of the email. Can be a list.\nsubject: The subject of the email.\ntext: The body of the email.\nfilename: The filename of the attachment\nfiletype: The filetype of the attachment\ndata: The attachment data.\ncc: cc recipient\nbcc: bcc recipient\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def create_message(  # noqa: PLR0913\n    sender: str,\n    recipient: str,\n    subject: str,\n    text: str,\n    filename: str,\n    filetype: str,\n    data: BytesIO | str,\n    cc: str | None = None,\n    bcc: str | None = None,\n) -&gt; MIMEMultipart:\n    \"\"\"Create email message.\n\n    Arguments:\n    ---------\n        sender: The sender of the email. Login will be made with this user.\n        recipient: The recipient of the email. Can be a list.\n        subject: The subject of the email.\n        text: The body of the email.\n        filename: The filename of the attachment\n        filetype: The filetype of the attachment\n        data: The attachment data.\n        cc: cc recipient\n        bcc: bcc recipient\n\n    \"\"\"\n    msg = MIMEMultipart()\n    msg[\"From\"] = sender\n    msg[\"To\"] = recipient\n    if cc:\n        msg[\"Cc\"] = cc\n    if bcc:\n        msg[\"Bcc\"] = bcc\n    msg[\"Date\"] = formatdate(localtime=True)\n    msg[\"Subject\"] = subject\n    # set body\n    msg.attach(MIMEText(text))\n    msg.attach(get_email_attachment(filename, filetype, data))\n\n    return msg\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.funge_release_date","title":"<code>funge_release_date(release_date='')</code>","text":"<p>Make a release_date from ACR conform to what seems to be the spec.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def funge_release_date(release_date: str = \"\") -&gt; str:\n    \"\"\"Make a release_date from ACR conform to what seems to be the spec.\"\"\"\n    if len(release_date) == 10:  # noqa: PLR2004\n        # we can make it look like what suisa has in their examples if it's the\n        # right length\n        try:\n            return datetime.strptime(release_date, \"%Y-%m-%d\").strftime(\"%Y%m%d\")  # noqa: DTZ007\n        except ValueError:\n            return \"\"\n    # we discard other records since there is no way to convert records like a plain\n    # year into dd/mm/yyyy properly without further guidance from whomever ingests\n    # the data, in some cases this means we discard data that only contain a year\n    # since they dont have that amount of precision.\n    return \"\"\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_artist","title":"<code>get_artist(music)</code>","text":"<p>Get artist from a given dict.</p> <pre><code>music: music dict from API\n</code></pre> <pre><code>artist: string representing the artist\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_artist(music: dict) -&gt; str:\n    \"\"\"Get artist from a given dict.\n\n    Arguments:\n    ---------\n        music: music dict from API\n\n    Returns:\n    -------\n        artist: string representing the artist\n\n    \"\"\"\n    artist = \"\"\n    if music.get(\"artists\") is not None:\n        artists = music.get(\"artists\")\n        if isinstance(artists, list):\n            artist = \", \".join([a.get(\"name\") for a in artists])\n        else:\n            # Yet another 'wrong' entry in the database:\n            # artists in custom_files was sometimes recorded as single value\n            # @TODO also remove once way in the past? (2023-01-31)\n            artist = cast(\"str\", artists)\n    elif music.get(\"artist\") is not None:\n        artist = cast(\"str\", music.get(\"artist\"))\n    elif music.get(\"Artist\") is not None:  # pragma: no cover\n        # Uppercase is a hack needed for Jun 2021 since there is a 'wrong' entry\n        # in the database. Going forward the record will be available as 'artist'\n        # in lowercase.\n        # @TODO remove once is waaaay in the past\n        artist = cast(\"str\", music.get(\"Artist\"))\n    return artist\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_composer","title":"<code>get_composer(music)</code>","text":"<p>Get composer from a given dict.</p> <pre><code>music: music dict from API\n</code></pre> <pre><code>composer: string representing the composer\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_composer(music: dict) -&gt; str:\n    \"\"\"Get composer from a given dict.\n\n    Arguments:\n    ---------\n        music: music dict from API\n\n    Returns:\n    -------\n        composer: string representing the composer\n\n    \"\"\"\n    # composers is usually represented as a list of strings, e.g.:\n    # 'contributors': {'composers': ['Alison Rachel Stewart', ...]}\n    # if composers is not in the expected format, we just return an empty string\n    composer = \"\"\n    contributors = music.get(\"contributors\")\n    if contributors is not None:\n        composers = contributors.get(\"composers\")\n        if composers is not None and isinstance(composers, list):\n            composer = \", \".join(composers)\n    return composer\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_csv","title":"<code>get_csv(data, settings)</code>","text":"<p>Create SUISA compatible csv data.</p> <pre><code>data: To data to create csv from\nsettings: The settings provided to the script\n</code></pre> <pre><code>csv: The converted data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_csv(data: list, settings: Settings) -&gt; str:\n    \"\"\"Create SUISA compatible csv data.\n\n    Arguments:\n    ---------\n        data: To data to create csv from\n        settings: The settings provided to the script\n\n    Returns:\n    -------\n        csv: The converted data\n\n    \"\"\"\n    station_name = settings.station.name\n    header = [\n        \"Sender\",\n        \"Titel des Musikwerks\",\n        \"Name des Komponisten\",\n        \"Interpret(en)\",\n        \"Sendedatum\",\n        \"Sendedauer\",\n        \"Sendezeit\",\n        \"ISRC\",\n        \"Label\",\n        \"Identifikationsnummer\",\n        \"Eigenaufnahmen\",\n        \"EAN / GTIN\",\n        \"Albumtitel / Titel des Tontr\u00e4gers\",\n        \"Aufnahmedatum\",\n        \"Aufnahmeland\",\n        \"Erstver\u00f6ffentlichungsdatum\",\n        \"Katalog-Nummer / CD ID\",\n        \"Werkverzeichnisangaben\",\n        \"Bestellnummer\",\n        \"Ver\u00f6ffentlichungsland\",\n        \"Liveaufnahme\",\n    ]\n    csv = StringIO()\n    csv_writer = writer(csv, dialect=\"excel\")\n    csv_writer.writerow(header)\n\n    for entry in tqdm(data, desc=\"preparing tracks for report\"):\n        metadata = entry.get(\"metadata\")\n        # parse timestamp\n        timestamp = datetime.strptime(metadata.get(\"timestamp_local\"), ACRClient.TS_FMT)  # noqa: DTZ007\n\n        ts_date = timestamp.strftime(\"%Y-%m-%d\")\n        ts_time = timestamp.strftime(\"%H:%M:%S\")\n        hours, remainder = divmod(metadata.get(\"played_duration\"), 60 * 60)\n        minutes, seconds = divmod(remainder, 60)\n        # required format of duration field: hh:mm:ss\n        duration = f\"{hours:02}:{minutes:02}:{seconds:02}\"\n\n        try:\n            music = metadata.get(\"music\")[0]\n        except TypeError:\n            music = metadata.get(\"custom_files\")[0]\n        title = music.get(\"title\")\n\n        artist = get_artist(music)\n        composer = get_composer(music)\n\n        works_composer = \", \".join(\n            [\n                c[\"name\"]\n                for c in [\n                    item\n                    for sublist in [w[\"creators\"] for w in music.get(\"works\", [])]\n                    for item in sublist\n                ]\n                if c.get(\"role\", \"\") in [\"C\", \"Composer\", \"W\", \"Writer\"]\n            ],\n        )\n        if works_composer and (not composer or composer == artist):\n            composer = works_composer\n\n        isrc = get_isrc(music)\n        label = music.get(\"label\")\n\n        # load some \"best-effort\" fields\n        album = music.get(\"album\", \"\")\n        cd_id = \"\"\n        # it's a dict if it's from the ACRCloud bucket, a string if from a custom bucket\n        if isinstance(album, dict):\n            cd_id = album.get(\"cd_id\", \"\")\n            album = album.get(\"name\", \"\")\n        upc = music.get(\"external_ids\", {}).get(\"upc\", \"\")\n        release_date = funge_release_date(music.get(\"release_date\", \"\"))\n\n        local_id: str = \"\"\n        # cridlib only supports timezone-aware datetime values, so we convert one\n        timestamp_utc = pytz.utc.localize(\n            datetime.strptime(metadata.get(\"timestamp_utc\"), ACRClient.TS_FMT),  # noqa: DTZ007\n        )\n        # we include the acrid in our CRID so we know about the data's provenience\n        # in case any questions about the data we delivered are asked\n        acrid = music.get(\"acrid\")\n\n        if settings.crid_mode == IdentifierMode.cridlib:\n            local_id = str(\n                cridlib.get(timestamp=timestamp_utc, fragment=f\"acrid={acrid}\")\n            )\n        elif settings.crid_mode == IdentifierMode.local:\n            local_id = f\"{timestamp_utc.isoformat()}#acrid={acrid}\"\n\n        csv_writer.writerow(\n            [\n                station_name,\n                title,\n                composer,\n                artist,\n                ts_date,\n                duration,\n                ts_time,\n                isrc,\n                label,\n                local_id,\n                \"nein\",  # Eigenaufnahmen\n                upc,\n                album,\n                \"\",  # Aufnahmedatum\n                \"\",  # Aufnahmeland\n                release_date,\n                cd_id,\n                \"\",  # Werkverzeichnisangaben\n                \"\",  # Bestellnummer\n                \"\",  # Ver\u00f6ffentlichungsland\n                \"\",  # Liveaufnahme\n            ],\n        )\n    return csv.getvalue()\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_email_attachment","title":"<code>get_email_attachment(filename, filetype, data)</code>","text":"<p>Create attachment based on required filetype and data.</p> <pre><code>filename: The filename of the attachment\nfiletype: The filetype of the attachment\ndata: The attachment data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_email_attachment(filename: str, filetype: str, data: BytesIO | str) -&gt; MIMEBase:\n    \"\"\"Create attachment based on required filetype and data.\n\n    Arguments:\n    ---------\n        filename: The filename of the attachment\n        filetype: The filetype of the attachment\n        data: The attachment data\n\n    \"\"\"\n    maintype = \"application\"\n    subtype = \"vnd.ms-excel\"\n    if filetype == \"csv\":\n        maintype = \"text\"\n        subtype = \"csv\"\n\n    payload = (\n        data.getvalue() if isinstance(data, BytesIO) else str(data).encode(\"utf-8\")\n    )\n\n    part = MIMEBase(maintype, subtype)\n    part.set_payload(payload)\n    encode_base64(part)\n    part.add_header(\n        \"Content-Disposition\", f\"attachment; filename={Path(filename).name}\"\n    )\n    return part\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_isrc","title":"<code>get_isrc(music)</code>","text":"<p>Get a valid ISRC from the music record or return an empty string.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_isrc(music: dict) -&gt; str:\n    \"\"\"Get a valid ISRC from the music record or return an empty string.\"\"\"\n    isrc = \"\"\n    if music.get(\"external_ids\", {}).get(\"isrc\"):\n        isrc = music.get(\"external_ids\", {}).get(\"isrc\")\n    elif music.get(\"isrc\"):\n        isrc = cast(\"str\", music.get(\"isrc\"))\n    # was a list with a singular entry for a while back in 2021\n    if isinstance(isrc, list):\n        isrc = isrc[0]\n    # some records contain the \"ISRC\" prefix that is described as legacy\n    # in the ISRC handbook from IFPI.\n    if isrc and isrc[:4] == \"ISRC\":\n        isrc = isrc[4:]\n    # take care of cases where the isrc is space delimited even though the\n    # record is technically wrong but happens often enough to warrant this\n    # hack.\n    if isrc:\n        isrc = isrc.replace(\" \", \"\")\n\n    if not ISRC.validate(isrc):\n        isrc = \"\"\n    return isrc\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.get_xlsx","title":"<code>get_xlsx(data, settings)</code>","text":"<p>Create SUISA compatible xlsx data.</p> <pre><code>data: The data to create xlsx from\nsettings: The settings provided to the script\n</code></pre> <pre><code>xlsx: The converted data as BytesIO object\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def get_xlsx(data: list[dict], settings: Settings) -&gt; BytesIO:\n    \"\"\"Create SUISA compatible xlsx data.\n\n    Arguments:\n    ---------\n        data: The data to create xlsx from\n        settings: The settings provided to the script\n\n    Returns:\n    -------\n        xlsx: The converted data as BytesIO object\n\n    \"\"\"\n    csv = get_csv(data, settings=settings)\n    csv_reader = reader(StringIO(csv))\n\n    xlsx = BytesIO()\n    workbook: Workbook = Workbook()\n    workbook.iso_dates = True\n    if not workbook.active:  # pragma: no cover\n        raise RuntimeError\n    worksheet: Worksheet = workbook.active  # type: ignore[assignment]\n\n    for row in csv_reader:\n        worksheet.append(row)\n\n    # the columns that should be styled as required (grey background)\n    required_columns = [\n        \"Sender\",\n        \"Titel des Musikwerks\",\n        \"Name des Komponisten\",\n        \"Interpret(en)\",\n        \"Sendedatum\",\n        \"Sendedauer\",\n        \"Sendezeit\",\n        \"ISRC\",\n        \"Label\",\n        \"Identifikationsnummer\",\n        \"Eigenaufnahmen\",\n    ]\n    subsidiary_columns = [\n        \"EAN/GTIN\",\n        \"Albumtitel / Titel des Tontr\u00e4gers\",\n        \"Aufnahmedatum\",\n        \"Aufnahmeland\",\n        \"Erstver\u00f6ffentlichungsdatum\",\n        \"Katalog-Nummer / CD ID\",\n        \"Werkverzeichnisangaben\",\n        \"Bestellnummer\",\n    ]\n    font = Font(name=\"Calibri\", bold=True, size=12)\n    side = Side(border_style=\"thick\", color=\"000000\")\n    border = Border(top=side, left=side, right=side, bottom=side)\n    required_fill = PatternFill(\"solid\", bgColor=\"bfbfbf\", fgColor=\"bfbfbf\")\n    subsdiary_fill = PatternFill(\"solid\", bgColor=\"ebf1de\", fgColor=\"ebf1de\")\n    for cell in worksheet[1]:  # xlsx is 1-indexed\n        cell.font = font\n        cell.border = border\n        if cell.value in required_columns:\n            cell.fill = required_fill\n        elif cell.value in subsidiary_columns:\n            cell.fill = subsdiary_fill\n\n    # Try to approximate the required width by finding the longest values per column\n    dims: dict[str, int] = {}\n    calc_row: tuple[Cell | MergedCell, ...]\n    for calc_row in worksheet.rows:\n        for cell in calc_row:\n            if isinstance(cell, Cell) and cell.value:\n                dims[cell.column_letter] = max(\n                    (dims.get(cell.column_letter, 0), len(str(cell.value))),\n                )\n    # apply estimated width to each column\n    padding = 3\n    for col, value in dims.items():\n        worksheet.column_dimensions[col].width = value + padding\n\n    reformat_start_date_in_xlsx(worksheet)\n\n    workbook.save(xlsx)\n    return xlsx\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.main","title":"<code>main(settings)</code>","text":"<p>ACRCloud client for SUISA reporting @ RaBe.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def main(settings: Settings) -&gt; None:  # pragma: no cover\n    \"\"\"ACRCloud client for SUISA reporting @ RaBe.\"\"\"\n    validate_arguments(settings)\n\n    start_date, end_date = parse_date(settings)\n    filename = parse_filename(settings, start_date)\n\n    client = ACRClient(bearer_token=str(settings.acr.bearer_token))\n    data = client.get_interval_data(\n        settings.acr.project_id,\n        str(settings.acr.stream_id),\n        start_date,\n        end_date,\n        timezone=settings.l10n.timezone,\n    )\n    data = merge_duplicates(data)\n    if settings.file.format == FileFormat.xlsx:\n        data = get_xlsx(data, settings=settings)\n    elif settings.file.format == FileFormat.csv:\n        data = get_csv(data, settings=settings)\n\n    if settings.output == OutputMode.email:\n        email_subject = Template(settings.email.subject).substitute(\n            {\n                \"station_name\": settings.station.name,\n                \"year\": format_date(\n                    start_date, format=\"yyyy\", locale=settings.l10n.locale\n                ),\n                \"month\": format_date(\n                    start_date, format=\"MM\", locale=settings.l10n.locale\n                ),\n            },\n        )\n        # generate body\n        text = Template(settings.email.text).substitute(\n            {\n                \"station_name\": settings.station.name,\n                \"month\": format_date(\n                    start_date, format=\"MMMM\", locale=settings.l10n.locale\n                ),\n                \"year\": format_date(\n                    start_date, format=\"yyyy\", locale=settings.l10n.locale\n                ),\n                \"previous_year\": format_date(\n                    start_date - timedelta(days=365),\n                    format=\"yyyy\",\n                    locale=settings.l10n.locale,\n                ),\n                \"in_three_months\": format_date(\n                    datetime.now() + relativedelta(months=+3),  # noqa: DTZ005\n                    format=\"long\",\n                    locale=settings.l10n.locale,\n                ),\n                \"responsible_email\": settings.email.responsible_email,\n                \"email_footer\": settings.email.footer,\n            },\n        )\n        msg = create_message(\n            settings.email.sender,\n            settings.email.to,\n            email_subject,\n            text,\n            filename,\n            settings.file.format,\n            data,  # pyright: ignore[reportArgumentType]\n            cc=settings.email.cc,\n            bcc=settings.email.bcc,\n        )\n        send_message(\n            msg,\n            server=settings.email.server,\n            port=settings.email.port,\n            login=settings.email.username,\n            password=settings.email.password,\n        )\n\n    elif settings.output == OutputMode.file and settings.file.format == FileFormat.xlsx:\n        write_xlsx(filename, data)  # pyright: ignore[reportArgumentType]\n    elif settings.output == OutputMode.file and settings.file.format == FileFormat.csv:\n        write_csv(filename, data)  # pyright: ignore[reportArgumentType]\n    elif (\n        settings.output == OutputMode.stdout and settings.file.format == FileFormat.csv\n    ):\n        print(data)  # noqa: T201\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.merge_duplicates","title":"<code>merge_duplicates(data)</code>","text":"<p>Merge consecutive entries into one if they are duplicates.</p> <pre><code>data: The data provided by ACRClient\n</code></pre> <pre><code>data: The processed data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def merge_duplicates(data: list) -&gt; list:\n    \"\"\"Merge consecutive entries into one if they are duplicates.\n\n    Arguments:\n    ---------\n        data: The data provided by ACRClient\n\n    Returns:\n    -------\n        data: The processed data\n\n    \"\"\"\n    prev = data[0]\n    mark = []\n    for entry in data[1:]:\n        if check_duplicate(prev, entry):\n            prev[\"metadata\"][\"played_duration\"] = (\n                prev[\"metadata\"][\"played_duration\"]\n                + entry[\"metadata\"][\"played_duration\"]\n            )\n            # mark entry for removal\n            mark.append(entry)\n        else:\n            prev = entry\n    # remove marked entries\n    for entry in mark:\n        data.remove(entry)\n    return data\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.parse_date","title":"<code>parse_date(settings)</code>","text":"<p>Parse date from args.</p> <pre><code>settings: The settings provided to the script\n</code></pre> <pre><code>start_date: the start date of the requested interval\nend_date: the end date of the requested interval\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def parse_date(settings: Settings) -&gt; tuple[date, date]:\n    \"\"\"Parse date from args.\n\n    Arguments:\n    ---------\n        settings: The settings provided to the script\n\n    Returns:\n    -------\n        start_date: the start date of the requested interval\n        end_date: the end date of the requested interval\n\n    \"\"\"\n    # default values\n    end_date: date = date.today()  # noqa: DTZ011\n    start_date: date = end_date - timedelta(days=30)\n\n    # date parsing logic\n    if settings.date.last_month:\n        today = date.today()  # noqa: DTZ011\n        # get first of this month\n        this_month = today.replace(day=1)\n        # last day of last month = first day of this month - 1 day\n        end_date = this_month - timedelta(days=1)\n        start_date = end_date.replace(day=1)\n    else:\n        if settings.date.end:\n            end_date = datetime.strptime(settings.date.end, \"%Y-%m-%d\").date()  # noqa: DTZ007\n        if settings.date.start:\n            start_date = datetime.strptime(settings.date.start, \"%Y-%m-%d\").date()  # noqa: DTZ007\n    return start_date, end_date\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.parse_filename","title":"<code>parse_filename(settings, start_date)</code>","text":"<p>Parse filename from settings and start_date.</p> <pre><code>settings: the settings provided to the script\nstart_date: start of reporting period\n</code></pre> <pre><code>filename: the filename to use for the csv data\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def parse_filename(settings: Settings, start_date: date) -&gt; str:\n    \"\"\"Parse filename from settings and start_date.\n\n    Arguments:\n    ---------\n        settings: the settings provided to the script\n        start_date: start of reporting period\n\n    Returns:\n    -------\n        filename: the filename to use for the csv data\n\n    \"\"\"\n    if settings.file.path:\n        filename = settings.file.path\n    # depending on date args either append the month or the start_date\n    elif settings.date.last_month:\n        date_part = f\"{start_date.strftime('%Y')}_{start_date.strftime('%m')}\"\n        filename = f\"{settings.station.name_short}_{date_part}.{settings.file.format}\"\n    else:\n        filename = (\n            f\"{settings.station.name_short}_\"\n            f\"{start_date.strftime('%Y-%m-%d')}.{settings.file.format}\"\n        )\n    return filename\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.reformat_start_date_in_xlsx","title":"<code>reformat_start_date_in_xlsx(worksheet)</code>","text":"<p>Set date number formatting on relevant columns.</p> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def reformat_start_date_in_xlsx(worksheet: Worksheet) -&gt; None:\n    \"\"\"Set date number formatting on relevant columns.\"\"\"\n    for idx, row in enumerate(worksheet.rows):\n        # skip first row\n        if idx &lt; 1:\n            continue\n\n        # turn the str from the CSV into a real datetime.datetime in Sendedatum column\n        row[4].value = datetime.strptime(  # noqa: DTZ007\n            f\"{row[4].value} {row[6].value}\", \"%Y-%m-%d %H:%M:%S\"\n        ).date()  # pyright: ignore[reportAttributeAccessIssue]\n        # adjust the formatting\n        row[4].number_format = \"dd.mm.yyyy\"\n\n        # same thing for date fields \"Aufnahmedatum\" and \"Erstver\u00f6ffentlichungsdatum\"\n        for col_idx in [13, 15]:\n            row[col_idx].value = (\n                datetime.strptime(  # noqa: DTZ007\n                    str(row[col_idx].value), \"%Y%m%d\"\n                ).date()\n                if row[col_idx].value\n                else None\n            )  # pyright: ignore[reportAttributeAccessIssue]\n            row[col_idx].number_format = \"dd.mm.yyyy\"\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.send_message","title":"<code>send_message(msg, server='127.0.0.1', port=587, login=None, password=None)</code>","text":"<p>Send email.</p> <pre><code>msg: The message to send (an email.message.Message object)\nserver: The SMTP server to use to send the email.\nport: The port of the SMTP server.\nlogin: The username for `sender`@`server`.\npassword: The password for `sender`@`server`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def send_message(\n    msg: MIMEMultipart,\n    server: str = \"127.0.0.1\",\n    port: int = 587,\n    login: str | None = None,\n    password: str | None = None,\n) -&gt; None:\n    \"\"\"Send email.\n\n    Arguments:\n    ---------\n        msg: The message to send (an email.message.Message object)\n        server: The SMTP server to use to send the email.\n        port: The port of the SMTP server.\n        login: The username for `sender`@`server`.\n        password: The password for `sender`@`server`.\n\n    \"\"\"\n    with SMTP(host=server, port=port) as smtp:\n        smtp.starttls()\n        if password:\n            if login:\n                smtp.login(login, password)\n            else:\n                smtp.login(msg[\"From\"], password)\n        smtp.send_message(msg)\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.validate_arguments","title":"<code>validate_arguments(settings)</code>","text":"<p>Validate the arguments provided to the script.</p> <p>After this function we are sure that there are no conflicts in the arguments.</p> <pre><code>settings: the Settings instance to validate\n</code></pre> <pre><code>InvalidValueError: if there are invalid argument combinations\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def validate_arguments(settings: Settings) -&gt; None:\n    \"\"\"Validate the arguments provided to the script.\n\n    After this function we are sure that there are no conflicts in the arguments.\n\n    Arguments:\n    ---------\n        settings: the Settings instance to validate\n\n    Raises:\n    ------\n        InvalidValueError: if there are invalid argument combinations\n\n    \"\"\"\n    msgs = []\n    # xlsx cannot be printed to stdout\n    if (\n        settings.output == OutputMode.stdout\n        and settings.file\n        and settings.file.format == FileFormat.xlsx\n    ):\n        msgs.append(\"xlsx cannot be printed to stdout, please set --file-format to csv\")\n    # last_month is in conflict with start_date and end_date\n    if settings.date.last_month and (settings.date.start or settings.date.end):\n        msgs.append(\"argument --last-month not allowed with --date-start or --date-end\")\n    # exit if there are error messages\n    if msgs:\n        raise InvalidValueError(msgs)\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.write_csv","title":"<code>write_csv(filename, csv)</code>","text":"<p>Write contents of <code>csv</code> to file.</p> <pre><code>filename: The file to write to.\ncsv: The data to write to `filename`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def write_csv(filename: str, csv: BytesIO | str) -&gt; None:  # pragma: no cover\n    \"\"\"Write contents of `csv` to file.\n\n    Arguments:\n    ---------\n        filename: The file to write to.\n        csv: The data to write to `filename`.\n\n    \"\"\"\n    with Path(filename).open(\"w\", encoding=\"utf-8\") as csvfile:\n        csvfile.write(str(csv))\n</code></pre>"},{"location":"reference/suisa_sendemeldung/#suisa_sendemeldung.write_xlsx","title":"<code>write_xlsx(filename, xlsx)</code>","text":"<p>Write contents of <code>xlsx</code> to file.</p> <pre><code>filename: The file to write to.\nxlsx: The data to write to `filename`.\n</code></pre> Source code in <code>suisa_sendemeldung/suisa_sendemeldung.py</code> <pre><code>def write_xlsx(filename: str, xlsx: BytesIO) -&gt; None:  # pragma: no cover\n    \"\"\"Write contents of `xlsx` to file.\n\n    Arguments:\n    ---------\n        filename: The file to write to.\n        xlsx: The data to write to `filename`.\n\n    \"\"\"\n    with Path(filename).open(\"wb\") as xlsxfile:\n        xlsxfile.write(xlsx.getvalue())\n</code></pre>"}]}